C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Src\main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) TABS(2) OBJECT
                    -(main.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "Declarations_GPIO.h"
   7          #include "Config_Globale.h"
   8          #include "Timers.h"
   9          #include "Servomoteur_Horizontal.h"
  10          #include "ultrason.h"
  11          #include "Config_SPI.h"
  12          #include "Transmission_SPI.h"
  13          #include "Config_ADC.h"
  14          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  15          #include "UART0_RingBuffer_lib.h"
  16          #include "ConfigUART1.h"
  17          #include "UART0_RingBuffer_lib.h"
  18          #include "Fonctions_cote_serializer.h"
  19          #include "Lien_Structure_commande.h"
  20          #include "Mesure_courant.h"
  21          
  22          #ifndef CFG_Globale
  23            #define CFG_Globale
  24            #include "CFG_Globale.h"
  25          #endif
  26          
  27          
  28          //------------------------------------------------------------------------------------
  29          // D�clarations des variables globales
  30          //------------------------------------------------------------------------------------
  31          int vitesse_par_defaut = 10;
  32          char message_PC_com[50] = {0};
  33          enum Epreuve epreuve_en_cours = Epreuve_non;
  34          int commande_correct = 0;
  35          double energie = 0;
  36          unsigned int courant = 0;
  37          
  38          char conversioncoord (unsigned char tableau[2]){
  39   1        int dizaine=0;
  40   1        int unite=0;
  41   1        char valeur;
  42   1        
  43   1        dizaine= (tableau[0]-'0')*10;
  44   1        unite= (tableau[1]-'0');
  45   1      
  46   1        valeur=dizaine+unite;
  47   1        return valeur ;
  48   1      }
  49          
  50          char conversioncoord_2 (unsigned char tableau[3]){
  51   1        int dizaine=0;
  52   1        int unite=0;
  53   1        int centaine = 0;
  54   1        char valeur;
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 2   

  55   1        
  56   1        centaine = (tableau[0]-'0')*100;
  57   1        dizaine= (tableau[1]-'0')*10;
  58   1        unite= (tableau[2]-'0');
  59   1      
  60   1        valeur=centaine+dizaine+unite;
  61   1        return valeur ;
  62   1      }
  63          
  64          /*char conversionvitesse (unsigned char tableau[3]){
  65            int centaine=0;
  66            int dizaine=0;
  67            int unite=0;
  68            char valeur;
  69          
  70            centaine= (tableau[0]-'0')*100;
  71            dizaine= (tableau[1]-'0')*10;
  72            unite= (tableau[2]-'0');
  73          
  74            valeur= centaine+dizaine+unite;
  75            return valeur ;
  76          }*/
  77          
  78          signed int conv(char* nbr, int taille)
  79          {
  80   1        int k=0;
  81   1        double t1 = 0;
  82   1        signed int ret=0;
  83   1        int numero=0;
  84   1      
  85   1        if(nbr[0]=='-')
  86   1        {
  87   2          for(k=1;k<taille;k++)
  88   2          {
  89   3            numero=nbr[k]-'0';
  90   3            t1 = pow(10,taille-1-k);
  91   3            numero = numero*ceil(pow(10,taille-1-k));
  92   3            ret+=numero;
  93   3          }
  94   2          ret=-1*ret;
  95   2        }
  96   1        else
  97   1        {
  98   2          for(k=0;k<taille;k++)
  99   2          {
 100   3            numero=(nbr[k]-'0')*ceil(pow(10,taille-1-k));
 101   3            ret+=numero;
 102   3          }
 103   2        }
 104   1        return ret;
 105   1      }
 106          signed int conversionangle_positif (unsigned char tableau[3]){
 107   1        signed int centaine=0;
 108   1        signed int dizaine=0;
 109   1        signed int unite=0;
 110   1        signed int valeur;
 111   1      
 112   1        if (tableau[0] == '-') {
 113   2          dizaine= (tableau[1]-'0')*10;
 114   2          unite= (tableau[2]-'0');
 115   2          valeur = -1* (dizaine + unite);
 116   2        }
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 3   

 117   1        else {
 118   2          centaine= (tableau[0]-'0')*100;
 119   2          dizaine= (tableau[1]-'0')*10;
 120   2          unite= (tableau[2]-'0');
 121   2          valeur= centaine+dizaine+unite;
 122   2        }
 123   1        return valeur ;
 124   1      }
 125          
 126          struct COMMANDES traitement_A(char * com, struct COMMANDES commande){ // traitement lorsque la premi�re 
             -lettre est A (AVANCER A DUREE DAQUISITION) AVANCER OK
 127   1        char vitesse;
 128   1        char tab[3];
 129   1        int j;
 130   1        char duree;
 131   1      
 132   1        switch (com[1]) //AJOUTER LA DUREE
 133   1            {
 134   2              case 'S': // cas ASS (Dur�e)
 135   2                {
 136   3                  commande_correct = 0; //TODO commande_correct = nbr pour aquisition signal
 137   3                  for (j=4; j<7;j++)
 138   3                    {
 139   4                    tab[j-4]=com[j];
 140   4                  }
 141   3                  duree=conversionangle_positif(tab);
 142   3                  if (duree >= 100 ||duree <1)
 143   3                    {
 144   4                    commande_correct = 0;
 145   4                  }
 146   3                  else{commande.ACQ_Duree=duree;}
 147   3                  break;
 148   3              }
 149   2              case ' ':// cas d'avancer A
 150   2              {
 151   3                if (epreuve_en_cours == epreuve1){
 152   4                  commande.Etat_Mouvement=Avancer;
 153   4                  // on regarde le param�tre de la vitesse
 154   4                  if (com[2] >= 0x30)
 155   4                  {
 156   5                    for (j=2; j<5;j++)
 157   5                      {
 158   6                        tab[j-2]=com[j];
 159   6                    }
 160   5                    vitesse=conversionangle_positif(tab);
 161   5                  if (vitesse >= 100 ||vitesse <=0)
 162   5                    {
 163   6                      commande_correct = 0;
 164   6                    }
 165   5                  else
 166   5                    {
 167   6                    commande.Vitesse=vitesse;
 168   6                    commande_correct = 1; // nbr 1 pour routage vers le serializer
 169   6      
 170   6                    }}
 171   4                  else{ commande_correct = 1; // nbr 1 pour routage vers le serializer
 172   5                  }
 173   4                }
 174   3                    else {
 175   4                      commande_correct = 2;
 176   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 177   3                break;
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 4   

 178   3              }
 179   2            default:
 180   2              {
 181   3              if (epreuve_en_cours == epreuve1){
 182   4                commande.Etat_Mouvement=Avancer;
 183   4                commande_correct = 1;}
 184   3                else{
 185   4                      commande_correct = 2;
 186   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 187   3            }
 188   2          }
 189   1          return commande;
 190   1      }
 191          struct COMMANDES traitement_B(char* com, struct COMMANDES commande) // RECULER OK
 192          {
 193   1        char vitesse;
 194   1        char tab[3];
 195   1        int j;
 196   1        commande.Etat_Mouvement=Reculer;
 197   1            if (com[1]==' ')
 198   1              {
 199   2              for (j=2; j<=4;j++)
 200   2              {
 201   3                  tab[j-2]=com[j];
 202   3              }
 203   2              vitesse=conversionangle_positif(tab);
 204   2                if (vitesse >= 100 ||vitesse <0)
 205   2                  {
 206   3                    commande_correct = 0;
 207   3                  }
 208   2                else
 209   2                  {
 210   3                  commande.Vitesse=vitesse;
 211   3                  commande_correct = 1;
 212   3                  }
 213   2              }
 214   1      
 215   1            else {
 216   2                  commande_correct = 1;
 217   2            }
 218   1      
 219   1            return commande;
 220   1      }
 221          struct COMMANDES traitement_C(char* com, struct COMMANDES commande) // pilotage du servomoteur
 222          {
 223   1        signed int angle;
 224   1        unsigned char tab[3];
 225   1        int j=0;
 226   1        switch (com[3])
 227   1        {
 228   2          case 'H':
 229   2          {
 230   3            commande.Etat_Servo=Servo_H;
 231   3            if (com[5]=='A')
 232   3              {
 233   4              for (j=7; j<10;j++)
 234   4                {
 235   5                    tab[j-7]=com[j];
 236   5                }
 237   4              angle=conversionangle_positif(tab);
 238   4                if (angle > 90 ||angle <-90)
 239   4                {
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 5   

 240   5                  commande_correct = 0;
 241   5                }
 242   4                else
 243   4                {
 244   5                  commande.Servo_Angle=angle;
 245   5                  commande_correct = 1;
 246   5                }
 247   4            }
 248   3            else
 249   3            {
 250   4              angle=0;
 251   4            }
 252   3            commande.Servo_Angle=angle;
 253   3            break;
 254   3          }
 255   2          case 'V':
 256   2          {
 257   3            commande.Etat_Servo=Servo_V;
 258   3            if (com[5]=='A')
 259   3              {
 260   4              for (j=7; j<10;j++)
 261   4                {
 262   5                    tab[j-7]=com[j];
 263   5                }
 264   4              angle=conversionangle_positif(tab);
 265   4                if (angle > 90 ||angle <-90)
 266   4                {
 267   5                  commande_correct = 0;
 268   5                }
 269   4                else
 270   4                {
 271   5                  commande.Servo_Angle=angle;
 272   5                  commande_correct = 1;
 273   5                }
 274   4            }
 275   3      
 276   3            else
 277   3            {
 278   4              angle=0;
 279   4              commande.Servo_Angle=angle;
 280   4            }
 281   3      
 282   3            break;
 283   3          }
 284   2          default:
 285   2          {
 286   3            commande.Etat_Servo=Servo_H;
 287   3            angle=0;
 288   3            commande.Servo_Angle=angle;
 289   3            break;
 290   3          }
 291   2        }
 292   1        return commande;
 293   1      }
 294          struct COMMANDES traitement_D(char * com, struct COMMANDES commande)// DEBUT DEPREUVE OK
 295          {
 296   1        switch (com[2]) // exemple message:  D 1
 297   1            {
 298   2              case '1': //�preuve 1
 299   2              {
 300   3                commande.Etat_Epreuve=epreuve1;
 301   3                strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 6   

 302   3                epreuve_en_cours = epreuve1;
 303   3                //serOutstring("Invite de commande 1");
 304   3                break;
 305   3      
 306   3              }
 307   2              case '2': //�preuve 2
 308   2              {
 309   3                commande.Etat_Epreuve=epreuve2;
 310   3                strcpy(message_PC_com, "\r\nInvite de commande 2\r\n>");
 311   3                epreuve_en_cours = epreuve2;
 312   3                //serOutstring("Invite de commande 2");
 313   3                break;
 314   3      
 315   3              }
 316   2              case '3': //�preuve 3
 317   2              {
 318   3                commande.Etat_Epreuve=epreuve3;
 319   3                epreuve_en_cours = epreuve3;
 320   3                strcpy(message_PC_com, "\r\nInvite de commande 3\r\n>");
 321   3                //serOutstring("Invite de commande 3");
 322   3                break;
 323   3      
 324   3              }
 325   2              case '4': //�preuve 4
 326   2              {
 327   3                commande.Etat_Epreuve=epreuve4;
 328   3                epreuve_en_cours = epreuve4;
 329   3                strcpy(message_PC_com, "\r\nInvite de commande 4\r\n>");
 330   3                //serOutstring("Invite de commande 4");
 331   3                break;
 332   3      
 333   3              }
 334   2              case '5': //�preuve 5
 335   2              {
 336   3                commande.Etat_Epreuve=epreuve5;
 337   3                epreuve_en_cours = epreuve5;
 338   3                strcpy(message_PC_com, "\r\nInvite de commande 5\r\n>");
 339   3                //serOutstring("Invite de commande 5");
 340   3                break;
 341   3              }
 342   2              case '6': //�preuve 6
 343   2              {
 344   3                commande.Etat_Epreuve=epreuve6;
 345   3                epreuve_en_cours = epreuve6;
 346   3                strcpy(message_PC_com, "\r\nInvite de commande 6\r\n>");
 347   3                //serOutstring("Invite de commande 6");
 348   3                break;
 349   3      
 350   3              }
 351   2              case '7': //�preuve 7
 352   2              {
 353   3                commande.Etat_Epreuve=epreuve7;
 354   3                epreuve_en_cours = epreuve7;
 355   3                strcpy(message_PC_com, "\r\nInvite de commande 7\r\n>");
 356   3                //serOutstring("Invite de commande 7");
 357   3                break;
 358   3              }
 359   2              case '8': //�preuve 8
 360   2              {
 361   3                commande.Etat_Epreuve=epreuve8;
 362   3                epreuve_en_cours = epreuve8;
 363   3                strcpy(message_PC_com, "\r\nInvite de commande 8\r\n>");
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 7   

 364   3                //serOutstring("Invite de commande 8");
 365   3                break;
 366   3              }
 367   2              default:
 368   2              {
 369   3              commande.Etat_Epreuve=epreuve1;
 370   3                epreuve_en_cours = epreuve1;
 371   3              strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 372   3              //serOutstring("Invite de commande 1");
 373   3      
 374   3              }
 375   2            }
 376   1            commande_correct = 2;
 377   1            return commande;
 378   1      }
 379          struct COMMANDES traitement_E(struct COMMANDES commande)//FIN DEPREUVE OK
 380          {
 381   1        //serOutstring("Fin de l'�preuve");
 382   1        commande.Etat_Epreuve=Epreuve_non;
 383   1        commande.Etat_Mouvement =Mouvement_non;
 384   1        epreuve_en_cours = Epreuve_non;
 385   1        return commande;
 386   1      }
 387          struct COMMANDES traitement_G(char * com, struct COMMANDES commande) // DEPLACEMENT AVEC ANGLE : OK
 388          {
 389   1          int i=4;
 390   1          int k=0;
 391   1          char coord[10];
 392   1          if (epreuve_en_cours == epreuve1 && com[1]==' ' && com[2]=='X' && com[3]==':')
 393   1          {
 394   2            commande.Etat_Mouvement = Depl_Coord;
 395   2      
 396   2            while(com[i]!= ' ')
 397   2            {
 398   3              coord[k]=com[i];
 399   3              i=i+1;
 400   3              k++;
 401   3            }
 402   2            coord[k]='\0';
 403   2            commande.Coord_X=conv(coord,strlen(coord));
 404   2            i = i+ 3;
 405   2            k=0;
 406   2            while(com[i]!= ' ')
 407   2            {
 408   3              coord[k]=com[i];
 409   3              i=i+1;
 410   3              k=k+1;
 411   3            }
 412   2            coord[i]='\0';
 413   2            commande.Coord_Y=conv(coord,strlen(coord));
 414   2            k=0;
 415   2            i = i+ 3;
 416   2            while(com[i]!= '\0')
 417   2            {
 418   3              coord[k]=com[i];
 419   3              i=i+1;
 420   3              k=k+1;
 421   3            }
 422   2            coord[i-1]='\0';
 423   2            commande.Angle=conv(coord,strlen(coord));
 424   2      
 425   2      
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 8   

 426   2          }
 427   1          else
 428   1          {
 429   2            commande_correct=0;
 430   2          }
 431   1      
 432   1      
 433   1            return commande;
 434   1      
 435   1      }
 436          
 437          /*struct COMMANDES traitement_I(char * com, struct COMMANDES commande) // pas encore utilis�
 438          {
 439            // a compl�ter
 440            return commande;
 441          }*/
 442          
 443          struct COMMANDES traitement_L(char * com,struct COMMANDES commande)
 444          {
 445   1        char Lumiere_Intensite;
 446   1        char Lumiere_Duree;
 447   1        char Lumiere_Extinction;
 448   1        char Lumiere_Nbre;
 449   1        unsigned char tab[4];
 450   1        int j;
 451   1      
 452   1        if (com[1]=='S'){
 453   2          commande.Etat_Lumiere=Eteindre;
 454   2        }
 455   1        else{
 456   2          switch(com[2]){
 457   3            case 'I':
 458   3            {
 459   4              for (j=4; j<8;j++){
 460   5                tab[j-4]=com[j];
 461   5              }
 462   4      
 463   4              Lumiere_Intensite = conversioncoord_2(tab);
 464   4              if (Lumiere_Intensite >= 0 & Lumiere_Intensite <= 100){
 465   5                  commande_correct=1;
 466   5                  commande.Lumiere_Intensite=Lumiere_Intensite;
 467   5              }
 468   4              else{
 469   5                  commande_correct=0;
 470   5              }
 471   4              for (j=10; j<13;j++){
 472   5                tab[j-10]=com[j];
 473   5              }
 474   4              
 475   4              Lumiere_Duree = conversioncoord_2(tab);
 476   4              if(Lumiere_Duree >= 1 && Lumiere_Duree <= 99){
 477   5                commande_correct=1;
 478   5                commande.Lumiere_Duree=Lumiere_Duree;
 479   5              }
 480   4              else{
 481   5                commande_correct=0;
 482   5              }
 483   4              for (j=16; j<19;j++){
 484   5                tab[j-16]=com[j];
 485   5              }
 486   4              Lumiere_Extinction =  conversioncoord_2(tab);
 487   4              if(Lumiere_Extinction>=0 && Lumiere_Extinction<=99){
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 9   

 488   5                commande_correct=1;
 489   5                commande.Lumiere_Extinction=Lumiere_Extinction;
 490   5              }
 491   4              else{
 492   5                commande_correct=0;
 493   5              }
 494   4              for (j=22; j<25;j++){
 495   5                tab[j-22]=com[j];
 496   5              }
 497   4              Lumiere_Nbre = conversioncoord_2(tab);
 498   4              if(Lumiere_Nbre>=0 && Lumiere_Nbre<=100){
 499   5                commande_correct=1;
 500   5                commande.Lumiere_Nbre=Lumiere_Nbre;
 501   5              }
 502   4              else{
 503   5                commande_correct=0;
 504   5              }
 505   4              break;
 506   4            }
 507   3            
 508   3            
 509   3            default:
 510   3            {
 511   4              commande.Lumiere_Intensite=100;
 512   4              commande.Lumiere_Nbre=1;
 513   4              commande.Lumiere_Extinction=0;
 514   4              commande.Lumiere_Duree=99;
 515   4              commande_correct=1;
 516   4              break;
 517   4            }
 518   3            break;
 519   3          }
 520   2        }
 521   1        return commande;
 522   1      }
 523          
 524          
 525          
 526          
 527          
 528          struct COMMANDES traitement_M(char *com, struct COMMANDES commande)
 529          {
 530   1        int j;
 531   1        char tab[2];
 532   1        char angle;
 533   1        switch(com[1])
 534   1          {
 535   2              case 'I': //MI Mesure de courant
 536   2                commande.Etat_Energie=Mesure_I;
 537   2                break;
 538   2              case 'E': //ME Mesure de l'�nergie
 539   2                commande.Etat_Energie=Mesure_E;
 540   2                break;
 541   2              case 'O': //cas MO
 542   2                switch (com[2])
 543   2                {
 544   3                  case 'U': // cas MOU
 545   3                    commande.A_Obst=Obst_unique;
 546   3                    switch (com[4])
 547   3                    {
 548   4                      case 'D':
 549   4                        commande.Det=avant_arriere;//avant et arriere
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 10  

 550   4                        break;
 551   4                      default:
 552   4                        commande.Det=avant;
 553   4                        //avant
 554   4                        break;
 555   4                    }
 556   3                    break;
 557   3                  case 'B': // cas MOB
 558   3                    commande.A_Obst=Obst_balayage;
 559   3                    switch(com[4])
 560   3                    {
 561   4                      case 'A':
 562   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 563   4                        for (j=6; j<8;j++)
 564   4                        {
 565   5                          tab[j-6]=com[j];
 566   5                        }
 567   4                        angle=conversioncoord(tab);
 568   4                        if (angle%5==0){
 569   5                          if(angle>=5 && angle<=45){
 570   6                            commande.DCT_Obst_Resolution=angle;
 571   6                            commande_correct=1;
 572   6                          }
 573   5                        }
 574   4                        else
 575   4                        {
 576   5                          commande_correct=0;
 577   5                        }
 578   4      
 579   4                        break;
 580   4                      case 'D':
 581   4                        commande.Etat_DCT_Obst=oui_180;
 582   4                        if (com[6]=='A')
 583   4                        {
 584   5                          for (j=8; j<10;j++)
 585   5                          {
 586   6                            tab[j-8]=com[j];
 587   6                          }
 588   5                          angle=conversioncoord(tab);
 589   5                          if (angle%5==0){
 590   6                            if(angle>=5 && angle<=45){
 591   7                              commande.DCT_Obst_Resolution=angle;
 592   7                              commande_correct=1;
 593   7                            }
 594   6                          }
 595   5                          else
 596   5                          {
 597   6                            commande_correct=0;
 598   6                          }
 599   5                        }
 600   4      
 601   4                        else
 602   4                        {
 603   5                          commande.DCT_Obst_Resolution=30;
 604   5                        }
 605   4                        break;
 606   4                      default:
 607   4                        commande.Etat_DCT_Obst=oui_360;
 608   4                        commande.DCT_Obst_Resolution=30;
 609   4                        break;
 610   4                    }
 611   3                    break;
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 11  

 612   3                  case 'S': // cas MOS
 613   3                    commande.A_Obst=Obst_proche_balayage;
 614   3                    switch(com[4])
 615   3                    {
 616   4                      case 'A':
 617   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 618   4                        for (j=6; j<8;j++)
 619   4                        {
 620   5                          tab[j-6]=com[j];
 621   5                        }
 622   4                        angle=conversioncoord(tab);
 623   4                        if (angle%5==0){
 624   5                          if(angle>=5 && angle<=45){
 625   6                            commande.DCT_Obst_Resolution=angle;
 626   6                            commande_correct=1;
 627   6                          }
 628   5                        }
 629   4                        else
 630   4                        {
 631   5                          commande_correct=0;
 632   5                        }
 633   4      
 634   4                        break;
 635   4                      case 'D':
 636   4                        commande.Etat_DCT_Obst=oui_180;
 637   4                        if (com[6]=='A')
 638   4                        {
 639   5                          for (j=8; j<10;j++)
 640   5                          {
 641   6                            tab[j-8]=com[j];
 642   6                          }
 643   5                          angle=conversioncoord(tab);
 644   5                          if (angle%5==0){
 645   6                            if(angle>=5 && angle<=45){
 646   7                              commande.DCT_Obst_Resolution=angle;
 647   7                              commande_correct=1;
 648   7                            }
 649   6                          }
 650   5                          else
 651   5                          {
 652   6                            commande_correct=0;
 653   6                          }
 654   5                        }
 655   4      
 656   4                        else
 657   4                        {
 658   5                          commande.DCT_Obst_Resolution=30;
 659   5                        }
 660   4                        break;
 661   4                      default:
 662   4                        commande.Etat_DCT_Obst=oui_360;
 663   4                        commande.DCT_Obst_Resolution=30;
 664   4                        break;
 665   4                    }
 666   3                    break;
 667   3                  default:break;
 668   3                }
 669   2                break;
 670   2              }
 671   1            return commande;
 672   1      }
 673          /*struct COMMANDES traitement_P(char *com, struct COMMANDES commande) // PAS ENCORE UTILISE (POS)
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 12  

 674          {
 675            // a compl�ter
 676            return commande;
 677          }*/
 678          struct COMMANDES traitement_Q(struct COMMANDES commande) //ARRET DURGENCE
 679          {
 680   1        //serOutstring("arret d'urgence");
 681   1        commande.Etat_Epreuve=Stop_Urgence;
 682   1        return commande;
 683   1      }
 684          struct COMMANDES traitement_R(char * com, struct COMMANDES commande)// DIFFERENTES ROTATIONS OK
 685          {
 686   1        signed int angle;
 687   1        unsigned char tab[3];
 688   1        int j;
 689   1        switch (com[1])
 690   1            {
 691   2            case 'D': // si on recoit RD
 692   2            {
 693   3              commande.Etat_Mouvement=Rot_90D;
 694   3              break;
 695   3            }
 696   2            case 'G': //Si on recoit RG
 697   2            {
 698   3              commande.Etat_Mouvement=Rot_90G;
 699   3              break;
 700   3            }
 701   2            case 'C':// si on recoit RC
 702   2            {
 703   3              if (com[3]== 'D')
 704   3              {
 705   4                commande.Etat_Mouvement=Rot_180D;
 706   4                break;
 707   4              }
 708   3              if (com[3]== 'G')
 709   3              {
 710   4                commande.Etat_Mouvement=Rot_180G;
 711   4                break;
 712   4              }
 713   3            }
 714   2            case 'A': // on recoit RA
 715   2            {
 716   3              switch (com[3])
 717   3              {
 718   4                case 'D':
 719   4                {
 720   5                  commande.Etat_Mouvement=Rot_AngD;
 721   5                  for (j=5; j<=7;j++)
 722   5                  {
 723   6                      tab[j-5]=com[j];
 724   6                  }
 725   5                  angle=conversionangle_positif(tab);
 726   5                  commande.Angle=angle;
 727   5                  break;
 728   5                }
 729   4                case 'G':
 730   4                {
 731   5                  commande.Etat_Mouvement=Rot_AngG;
 732   5                  for (j=5; j<=7;j++)
 733   5                  {
 734   6                      tab[j-5]=com[j];
 735   6                  }
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 13  

 736   5                  angle=conversionangle_positif(tab);
 737   5                  commande.Angle=angle;
 738   5                  break;
 739   5                }
 740   4                default :
 741   4                {
 742   5                  commande.Etat_Mouvement=Rot_AngD;
 743   5                  angle=90;
 744   5                  commande.Angle=angle;
 745   5                  break;
 746   5                }
 747   4            }
 748   3            break;
 749   3          }
 750   2            default:
 751   2            {
 752   3              break;
 753   3            }
 754   2          }
 755   1          return commande;
 756   1      }
 757          struct COMMANDES traitement_S(char * com, struct COMMANDES commande/*,char f_b, char t_son, char t_silence
             -, char bip_b*/) // STOPPER
 758          {
 759   1        int i;
 760   1        char f_b=6;
 761   1        char t_son=25;
 762   1        char t_silence=50;
 763   1        char bip_b=3;
 764   1        char tab[2];
 765   1        char frequence;
 766   1        char duree_son;
 767   1        char duree_silence;
 768   1        char nombre_Bips;
 769   1      
 770   1        if( com[1]=='D')
 771   1        {
 772   2          commande.son=emission;
 773   2            if(com[3]=='F')
 774   2            {
 775   3              for (i=5; i<7;i++)
 776   3              {
 777   4                tab[i-5]=com[i];
 778   4              }
 779   3              frequence=conversioncoord(tab);
 780   3              if (frequence >99 ||frequence <1)
 781   3              {
 782   4                  commande_correct = 0;
 783   4              }
 784   3              else
 785   3              {
 786   4                commande.frequence=frequence;
 787   4                commande_correct = 1;
 788   4              }
 789   3              for (i=10; i<12;i++)
 790   3              {
 791   4                tab[i-10]=com[i];
 792   4              }
 793   3              duree_son=conversioncoord(tab);
 794   3              if (duree_son >99 ||duree_son <1)
 795   3              {
 796   4                  commande_correct = 0;
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 14  

 797   4              }
 798   3              else
 799   3              {
 800   4                commande.duree_son=duree_son;
 801   4                commande_correct = 1;
 802   4              }
 803   3              for (i=15; i<17;i++)
 804   3              {
 805   4                tab[i-15]=com[i];
 806   4              }
 807   3              duree_silence=conversioncoord(tab);
 808   3              if (duree_silence >99 ||duree_silence <1)
 809   3              {
 810   4                  commande_correct = 0;
 811   4              }
 812   3              else
 813   3              {
 814   4                commande.duree_silence=duree_silence;
 815   4                commande_correct = 1;
 816   4              }
 817   3              for (i=20; i<22;i++)
 818   3              {
 819   4                tab[i-20]=com[i];
 820   4              }
 821   3              nombre_Bips=conversioncoord(tab);
 822   3              if (nombre_Bips >99 ||nombre_Bips <1)
 823   3              {
 824   4                  commande_correct = 0;
 825   4              }
 826   3              else
 827   3              {
 828   4                commande.nombre_Bips=nombre_Bips;
 829   4                commande_correct = 1;
 830   4              }
 831   3      
 832   3            }
 833   2            else
 834   2            {
 835   3              commande.frequence=f_b;               // d�finit par le code fr�quence allant de 1 a 99 (mais defini de 1
             - a 21)
 836   3              commande.duree_son=t_son;                 // dur�e du signal sonore
 837   3              commande.duree_silence=t_silence;             // duree du silence
 838   3              commande.nombre_Bips=bip_b;             // nombre de bips
 839   3            }
 840   2        }
 841   1        else
 842   1        {
 843   2          commande.Etat_Mouvement=Stopper;
 844   2        }
 845   1        return commande;
 846   1      }
 847          struct COMMANDES traitement_T(char * com, struct COMMANDES commande) // VITESSE A REGLER
 848          {
 849   1        char vitesse;
 850   1        char tab[3];
 851   1        int j;
 852   1        // on regarde le param�tre de la vitesse
 853   1      
 854   1        for (j=3; j<=5;j++)
 855   1        {
 856   2            tab[j-3]=com[j];
 857   2        }
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 15  

 858   1        vitesse=conversionangle_positif(tab);
 859   1        j = ((int)vitesse& 0x00FF);
 860   1        if (j >= 100){
 861   2            commande_correct = 0;}
 862   1        else {
 863   2            vitesse_par_defaut=(vitesse & 0x00FF);
 864   2            strcpy(message_PC_com,"\r\n>");
 865   2            commande_correct = 2;
 866   2        }
 867   1        return commande;
 868   1      
 869   1      }
 870          
 871          struct COMMANDES Message (char * com/*, char f_b,char t_son,char t_silence,char bip_b*/){
 872   1      //  char tabcoordx[2];
 873   1      //  char tabcoordy[2];
 874   1      //  char tabangle[2];
 875   1      //  signed char coordx;
 876   1      //  signed char coordy;
 877   1      //  char angle;
 878   1      //  int cpt=0;
 879   1        //a modifier
 880   1      
 881   1      
 882   1      
 883   1        struct COMMANDES commande;
 884   1        commande.Etat_Epreuve = Epreuve_non;
 885   1        commande.Vitesse = vitesse_par_defaut;
 886   1        commande.Etat_Mouvement = Mouvement_non;
 887   1        commande.Etat_ACQ_Son = ACQ_non;
 888   1        commande.A_Obst = Non_obst;
 889   1        commande.Etat_DCT_Obst = DCT_non;
 890   1        commande.Etat_Lumiere = Lumiere_non;
 891   1        commande.Etat_Servo = Servo_non;
 892   1        commande.Etat_Energie = Energie_non;
 893   1        commande.Etat_Photo = Photo_non;
 894   1        commande.Etat_Position = Position_non;
 895   1        commande.son=non_emission;
 896   1      
 897   1          switch (com[0])
 898   1          {
 899   2          case 'A':// si on recoit un A AVANCER OU DUREE DAQUISITION FIXEE
 900   2          {
 901   3            commande=traitement_A(com,commande);
 902   3            break;
 903   3          }
 904   2          case 'T':// si on recoit un TV Reglage de la vitesse seulement
 905   2          {
 906   3            commande=traitement_T(com,commande);
 907   3            break;
 908   3          }
 909   2          case 'D':// si on recoit un D (D�but de l'epreuve)
 910   2          {
 911   3            commande=traitement_D(com,commande);
 912   3            break;
 913   3          }
 914   2          case 'E':// si on recoit un E (fin de l'epreuve)
 915   2          {
 916   3            commande=traitement_E(commande);
 917   3            break;
 918   3      
 919   3          }
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 16  

 920   2          case 'Q':// si on recoit un Q (arret d'urgence)
 921   2          {
 922   3            commande=traitement_Q(commande);
 923   3            break;
 924   3      
 925   3          }
 926   2          case 'L':// si on recoit un M (mesure et autre)
 927   2          {
 928   3            commande=traitement_L(com,commande);
 929   3            break;
 930   3          }
 931   2          case 'M':// si on recoit un M (mesure et autre)
 932   2          {
 933   3            commande=traitement_M(com,commande);
 934   3            break;
 935   3          }
 936   2          case 'I':// si on recoit un IPO (I)
 937   2          {
 938   3            // a faire
 939   3            //commande=traitement_I(com,commande);
 940   3            break;
 941   3          }
 942   2          case 'P':// si on recoit un POS
 943   2          {
 944   3            //commande=traitement_P(com,commande);
 945   3            //envoie de information
 946   3            break;
 947   3      
 948   3          }
 949   2          case 'B': //si on recoit un B RECULER
 950   2          {
 951   3            commande=traitement_B(com,commande);
 952   3            break;
 953   3          }
 954   2          case 'S': // si on recoit S
 955   2          {
 956   3            commande=traitement_S(com, commande/*,f_b, t_son, t_silence, bip_b*/);
 957   3      
 958   3            break;
 959   3          }
 960   2          case 'G': // si on recoit G
 961   2          {
 962   3            commande=traitement_G(com,commande);
 963   3            break;
 964   3          }
 965   2      
 966   2          case 'R': //Si On recoit R ROTATION
 967   2          {
 968   3            commande=traitement_R(com,commande);
 969   3            break;
 970   3          }
 971   2          case 'C':
 972   2            commande=traitement_C(com,commande);
 973   2            break;
 974   2          default:
 975   2          {
 976   3          commande_correct = 0;
 977   3          }
 978   2      }
 979   1      //}
 980   1      return commande;
 981   1      }
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 17  

 982          
 983          
 984          
 985          void main (void)
 986          {
 987   1      //D�claration des variables
 988   1        //struct COMMANDES_SERIALIZER commande_serializer;
 989   1        struct COMMANDES commande;
 990   1        char message_s[50] = {0};
 991   1        char mess[6] = {0};
 992   1        char echo[3] = {0};
 993   1        char com[50] = {0};
 994   1      //  char nbr[10];
 995   1        char a;
 996   1        char i =0;
 997   1        int b = 0;
 998   1        unsigned char code_err = 0;
 999   1      
1000   1        //a modifier
1001   1        char f_b=6;
1002   1        char t_son=25;
1003   1        char t_silence=50;
1004   1        char bip_b=3;
1005   1      
1006   1        EA=0;
1007   1        Init_Device();  // Initialisation du microcontr�leur
1008   1        Config_Timer2();
1009   1        Config_timer0();
1010   1        Config_Timer3();
1011   1        Config_SPI_MASTER();
1012   1        CFG_VREF();
1013   1        CFG_ADC0();
1014   1        CFG_Clock_UART();
1015   1        cfg_UART0_mode1();
1016   1        init_Serial_Buffer();
1017   1        init_Serial_Buffer1();
1018   1        CFG_UART1();
1019   1        NSS_slave = 1;
1020   1        TR2 = 0;
1021   1        energie = 0;
1022   1        EA=1;
1023   1      
1024   1        serOutstring("\n\rDemarrage robot\n\r>");
1025   1      // a commenter si le robot est d�ja allum� avant le lancement du code
1026   1      // Pour recevoir le message de d�marrage du serializer
1027   1      /*  do{
1028   1            a=serInchar1();
1029   1            echo[0] = a;
1030   1            echo[1] = '\0';
1031   1            serOutstring(echo);
1032   1            memset(echo,0,strlen(echo));
1033   1          }while(a!=0x3E);
1034   1      */
1035   1        while(1){
1036   2      
1037   2          memset(message_s,0,sizeof(message_s));
1038   2          memset(mess, 0, strlen(mess));
1039   2          memset(message_PC_com, 0, strlen(message_PC_com));
1040   2      
1041   2          commande_correct =1;
1042   2      
1043   2          i=0;
C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 18  

1044   2          a=0;
1045   2          memset(com, 0, 50);
1046   2          /*do{
1047   2            a=serInchar();
1048   2            echo[0] = a;
1049   2            echo[1] = '\0';
1050   2            serOutstring(echo);
1051   2            memset(echo,0,strlen(echo));
1052   2            if (a!=0x00)
1053   2              {
1054   2              com[i]=a;
1055   2              i=i+1;
1056   2              }
1057   2            }while(a!=0x0D); //Commenté pour les tests avec le simulateur*/
1058   2      
1059   2          //strcpy(com,"CS V A:-45");
1060   2          //strcpy(com,"SD F:12 P:50 W:60 B:05");
1061   2          //strcpy(com,"MOB");
1062   2          //strcpy(com,"L I:100 D:007 E:006 N:090");
1063   2          strcpy(com,"L");
1064   2      
1065   2      
1066   2      
1067   2          commande = Message(com);
1068   2            
1069   2          if (commande_correct == 1){
1070   3              fonctionRoutage(commande);
1071   3          }
1072   2          if (commande_correct == 2){
1073   3            serOutstring(message_PC_com); // si erreur
1074   3          }
1075   2          if(commande_correct == 0){
1076   3            strcpy(mess, "\n\r#\n\r>");
1077   3            serOutstring(mess); // si erreur
1078   3          }
1079   2        //serOutstring(message_PC_com); // si erreur
1080   2        }
1081   1      
1082   1      }
1083          
1084          void ISR_Timer2 (void) interrupt 5 {
1085   1        TF2 = 0; //Remise � '0' du flag d'overflow
1086   1        PWM_servo=!PWM_servo; //On envoie le signal PWM au servomoteur
1087   1      }
1088          
1089          void ISR_Timer3 (void) interrupt 14 {
1090   1        TMR3CN &= 0x04; //Remise � '0' du flag d'overflow
1091   1        courant = Courant_ADC();
1092   1        energie += 9.6*courant*0.001*0.035;
1093   1        
1094   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6061    ----
   CONSTANT SIZE    =    377    ----
   XDATA SIZE       =     61     764
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.51   MAIN                                                                  05/23/2018 10:37:22 PAGE 19  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
