C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Src\main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) TABS(2) OBJECT
                    -(main.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "Declarations_GPIO.h"
   7          #include "Config_Globale.h"
   8          #include "Timers.h"
   9          #include "Servomoteur_Horizontal.h"
  10          #include "ultrason.h"
  11          #include "Config_SPI.h"
  12          #include "Transmission_SPI.h"
  13          #include "Config_ADC.h"
  14          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  15          #include "UART0_RingBuffer_lib.h"
  16          #include "ConfigUART1.h"
  17          #include "UART0_RingBuffer_lib.h"
  18          #include "Fonctions_cote_serializer.h"
  19          #include "Lien_Structure_commande.h"
  20          #include "Mesure_courant.h"
  21          
  22          #ifndef CFG_Globale
  23            #define CFG_Globale
  24            #include "CFG_Globale.h"
  25          #endif
  26          
  27          
  28          //------------------------------------------------------------------------------------
  29          // D�clarations des variables globales
  30          //------------------------------------------------------------------------------------
  31          int vitesse_par_defaut = 10;
  32          char message_PC_com[50] = {0};
  33          enum Epreuve epreuve_en_cours = Epreuve_non;
  34          int commande_correct = 0;
  35          double energie = 0;
  36          
  37          char conversioncoord (unsigned char tableau[2]){
  38   1        int dizaine=0;
  39   1        int unite=0;
  40   1        char valeur;
  41   1      
  42   1        dizaine= (tableau[0]-'0')*10;
  43   1        unite= (tableau[1]-'0');
  44   1      
  45   1        valeur=dizaine+unite;
  46   1        return valeur ;
  47   1      }
  48          
  49          /*char conversionvitesse (unsigned char tableau[3]){
  50            int centaine=0;
  51            int dizaine=0;
  52            int unite=0;
  53            char valeur;
  54          
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 2   

  55            centaine= (tableau[0]-'0')*100;
  56            dizaine= (tableau[1]-'0')*10;
  57            unite= (tableau[2]-'0');
  58          
  59            valeur= centaine+dizaine+unite;
  60            return valeur ;
  61          }*/
  62          
  63          signed int conv(char* nbr, int taille)
  64          {
  65   1        int k=0;
  66   1        double t1 = 0;
  67   1        signed int ret=0;
  68   1        int numero=0;
  69   1      
  70   1        if(nbr[0]=='-')
  71   1        {
  72   2          for(k=1;k<taille;k++)
  73   2          {
  74   3            numero=nbr[k]-'0';
  75   3            t1 = pow(10,taille-1-k);
  76   3            numero = numero*ceil(pow(10,taille-1-k));
  77   3            ret+=numero;
  78   3          }
  79   2          ret=-1*ret;
  80   2        }
  81   1        else
  82   1        {
  83   2          for(k=0;k<taille;k++)
  84   2          {
  85   3            numero=(nbr[k]-'0')*ceil(pow(10,taille-1-k));
  86   3            ret+=numero;
  87   3          }
  88   2        }
  89   1        return ret;
  90   1      }
  91          signed int conversionangle_positif (unsigned char tableau[3]){
  92   1        signed int centaine=0;
  93   1        signed int dizaine=0;
  94   1        signed int unite=0;
  95   1        signed int valeur;
  96   1      
  97   1        if (tableau[0] == '-') {
  98   2          dizaine= (tableau[1]-'0')*10;
  99   2          unite= (tableau[2]-'0');
 100   2          valeur = -1* (dizaine + unite);
 101   2        }
 102   1        else {
 103   2          centaine= (tableau[0]-'0')*100;
 104   2          dizaine= (tableau[1]-'0')*10;
 105   2          unite= (tableau[2]-'0');
 106   2          valeur= centaine+dizaine+unite;
 107   2        }
 108   1        return valeur ;
 109   1      }
 110          
 111          struct COMMANDES traitement_A(char * com, struct COMMANDES commande){ // traitement lorsque la premi�re 
             -lettre est A (AVANCER A DUREE DAQUISITION) AVANCER OK
 112   1        char vitesse;
 113   1        char tab[3];
 114   1        int j;
 115   1        char duree;
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 3   

 116   1      
 117   1        switch (com[1]) //AJOUTER LA DUREE
 118   1            {
 119   2              case 'S': // cas ASS (Dur�e)
 120   2                {
 121   3                  commande_correct = 0; //TODO commande_correct = nbr pour aquisition signal
 122   3                  for (j=4; j<7;j++)
 123   3                    {
 124   4                    tab[j-4]=com[j];
 125   4                  }
 126   3                  duree=conversionangle_positif(tab);
 127   3                  if (duree >= 100 ||duree <1)
 128   3                    {
 129   4                    commande_correct = 0;
 130   4                  }
 131   3                  else{commande.ACQ_Duree=duree;}
 132   3                  break;
 133   3              }
 134   2              case ' ':// cas d'avancer A
 135   2              {
 136   3                if (epreuve_en_cours == epreuve1){
 137   4                  commande.Etat_Mouvement=Avancer;
 138   4                  // on regarde le param�tre de la vitesse
 139   4                  if (com[2] >= 0x30)
 140   4                  {
 141   5                    for (j=2; j<5;j++)
 142   5                      {
 143   6                        tab[j-2]=com[j];
 144   6                    }
 145   5                    vitesse=conversionangle_positif(tab);
 146   5                  if (vitesse >= 100 ||vitesse <=0)
 147   5                    {
 148   6                      commande_correct = 0;
 149   6                    }
 150   5                  else
 151   5                    {
 152   6                    commande.Vitesse=vitesse;
 153   6                    commande_correct = 1; // nbr 1 pour routage vers le serializer
 154   6      
 155   6                    }}
 156   4                  else{ commande_correct = 1; // nbr 1 pour routage vers le serializer
 157   5                  }
 158   4                }
 159   3                    else {
 160   4                      commande_correct = 2;
 161   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 162   3                break;
 163   3              }
 164   2            default:
 165   2              {
 166   3              if (epreuve_en_cours == epreuve1){
 167   4                commande.Etat_Mouvement=Avancer;
 168   4                commande_correct = 1;}
 169   3                else{
 170   4                      commande_correct = 2;
 171   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 172   3            }
 173   2          }
 174   1          return commande;
 175   1      }
 176          struct COMMANDES traitement_B(char* com, struct COMMANDES commande) // RECULER OK
 177          {
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 4   

 178   1        char vitesse;
 179   1        char tab[3];
 180   1        int j;
 181   1        commande.Etat_Mouvement=Reculer;
 182   1            if (com[1]==' ')
 183   1              {
 184   2              for (j=2; j<=4;j++)
 185   2              {
 186   3                  tab[j-2]=com[j];
 187   3              }
 188   2              vitesse=conversionangle_positif(tab);
 189   2                if (vitesse >= 100 ||vitesse <0)
 190   2                  {
 191   3                    commande_correct = 0;
 192   3                  }
 193   2                else
 194   2                  {
 195   3                  commande.Vitesse=vitesse;
 196   3                  commande_correct = 1;
 197   3                  }
 198   2              }
 199   1      
 200   1            else {
 201   2                  commande_correct = 1;
 202   2            }
 203   1      
 204   1            return commande;
 205   1      }
 206          struct COMMANDES traitement_C(char* com, struct COMMANDES commande) // pilotage du servomoteur
 207          {
 208   1        signed int angle;
 209   1        unsigned char tab[3];
 210   1        int j=0;
 211   1        switch (com[3])
 212   1        {
 213   2          case 'H':
 214   2          {
 215   3            commande.Etat_Servo=Servo_H;
 216   3            if (com[5]=='A')
 217   3              {
 218   4              for (j=7; j<10;j++)
 219   4                {
 220   5                    tab[j-7]=com[j];
 221   5                }
 222   4              angle=conversionangle_positif(tab);
 223   4                if (angle > 90 ||angle <-90)
 224   4                {
 225   5                  commande_correct = 0;
 226   5                }
 227   4                else
 228   4                {
 229   5                  commande.Servo_Angle=angle;
 230   5                  commande_correct = 1;
 231   5                }
 232   4            }
 233   3            else
 234   3            {
 235   4              angle=0;
 236   4            }
 237   3            commande.Servo_Angle=angle;
 238   3            break;
 239   3          }
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 5   

 240   2          case 'V':
 241   2          {
 242   3            commande.Etat_Servo=Servo_V;
 243   3            if (com[5]=='A')
 244   3              {
 245   4              for (j=7; j<10;j++)
 246   4                {
 247   5                    tab[j-7]=com[j];
 248   5                }
 249   4              angle=conversionangle_positif(tab);
 250   4                if (angle > 90 ||angle <-90)
 251   4                {
 252   5                  commande_correct = 0;
 253   5                }
 254   4                else
 255   4                {
 256   5                  commande.Servo_Angle=angle;
 257   5                  commande_correct = 1;
 258   5                }
 259   4            }
 260   3      
 261   3            else
 262   3            {
 263   4              angle=0;
 264   4              commande.Servo_Angle=angle;
 265   4            }
 266   3      
 267   3            break;
 268   3          }
 269   2          default:
 270   2          {
 271   3            commande.Etat_Servo=Servo_H;
 272   3            angle=0;
 273   3            commande.Servo_Angle=angle;
 274   3            break;
 275   3          }
 276   2        }
 277   1        return commande;
 278   1      }
 279          struct COMMANDES traitement_D(char * com, struct COMMANDES commande)// DEBUT DEPREUVE OK
 280          {
 281   1        switch (com[2]) // exemple message:  D 1
 282   1            {
 283   2              case '1': //�preuve 1
 284   2              {
 285   3                commande.Etat_Epreuve=epreuve1;
 286   3                strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 287   3                epreuve_en_cours = epreuve1;
 288   3                //serOutstring("Invite de commande 1");
 289   3                break;
 290   3      
 291   3              }
 292   2              case '2': //�preuve 2
 293   2              {
 294   3                commande.Etat_Epreuve=epreuve2;
 295   3                strcpy(message_PC_com, "\r\nInvite de commande 2\r\n>");
 296   3                epreuve_en_cours = epreuve2;
 297   3                //serOutstring("Invite de commande 2");
 298   3                break;
 299   3      
 300   3              }
 301   2              case '3': //�preuve 3
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 6   

 302   2              {
 303   3                commande.Etat_Epreuve=epreuve3;
 304   3                epreuve_en_cours = epreuve3;
 305   3                strcpy(message_PC_com, "\r\nInvite de commande 3\r\n>");
 306   3                //serOutstring("Invite de commande 3");
 307   3                break;
 308   3      
 309   3              }
 310   2              case '4': //�preuve 4
 311   2              {
 312   3                commande.Etat_Epreuve=epreuve4;
 313   3                epreuve_en_cours = epreuve4;
 314   3                strcpy(message_PC_com, "\r\nInvite de commande 4\r\n>");
 315   3                //serOutstring("Invite de commande 4");
 316   3                break;
 317   3      
 318   3              }
 319   2              case '5': //�preuve 5
 320   2              {
 321   3                commande.Etat_Epreuve=epreuve5;
 322   3                epreuve_en_cours = epreuve5;
 323   3                strcpy(message_PC_com, "\r\nInvite de commande 5\r\n>");
 324   3                //serOutstring("Invite de commande 5");
 325   3                break;
 326   3              }
 327   2              case '6': //�preuve 6
 328   2              {
 329   3                commande.Etat_Epreuve=epreuve6;
 330   3                epreuve_en_cours = epreuve6;
 331   3                strcpy(message_PC_com, "\r\nInvite de commande 6\r\n>");
 332   3                //serOutstring("Invite de commande 6");
 333   3                break;
 334   3      
 335   3              }
 336   2              case '7': //�preuve 7
 337   2              {
 338   3                commande.Etat_Epreuve=epreuve7;
 339   3                epreuve_en_cours = epreuve7;
 340   3                strcpy(message_PC_com, "\r\nInvite de commande 7\r\n>");
 341   3                //serOutstring("Invite de commande 7");
 342   3                break;
 343   3              }
 344   2              case '8': //�preuve 8
 345   2              {
 346   3                commande.Etat_Epreuve=epreuve8;
 347   3                epreuve_en_cours = epreuve8;
 348   3                strcpy(message_PC_com, "\r\nInvite de commande 8\r\n>");
 349   3                //serOutstring("Invite de commande 8");
 350   3                break;
 351   3              }
 352   2              default:
 353   2              {
 354   3              commande.Etat_Epreuve=epreuve1;
 355   3                epreuve_en_cours = epreuve1;
 356   3              strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 357   3              //serOutstring("Invite de commande 1");
 358   3      
 359   3              }
 360   2            }
 361   1            commande_correct = 2;
 362   1            return commande;
 363   1      }
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 7   

 364          struct COMMANDES traitement_E(struct COMMANDES commande)//FIN DEPREUVE OK
 365          {
 366   1        //serOutstring("Fin de l'�preuve");
 367   1        commande.Etat_Epreuve=Epreuve_non;
 368   1        commande.Etat_Mouvement =Mouvement_non;
 369   1        epreuve_en_cours = Epreuve_non;
 370   1        return commande;
 371   1      }
 372          struct COMMANDES traitement_G(char * com, struct COMMANDES commande) // DEPLACEMENT AVEC ANGLE : OK
 373          {
 374   1          int i=4;
 375   1          int k=0;
 376   1          char coord[10];
 377   1          if (epreuve_en_cours == epreuve1 && com[1]==' ' && com[2]=='X' && com[3]==':')
 378   1          {
 379   2            commande.Etat_Mouvement = Depl_Coord;
 380   2      
 381   2            while(com[i]!= ' ')
 382   2            {
 383   3              coord[k]=com[i];
 384   3              i=i+1;
 385   3              k++;
 386   3            }
 387   2            coord[k]='\0';
 388   2            commande.Coord_X=conv(coord,strlen(coord));
 389   2            i = i+ 3;
 390   2            k=0;
 391   2            while(com[i]!= ' ')
 392   2            {
 393   3              coord[k]=com[i];
 394   3              i=i+1;
 395   3              k=k+1;
 396   3            }
 397   2            coord[i]='\0';
 398   2            commande.Coord_Y=conv(coord,strlen(coord));
 399   2            k=0;
 400   2            i = i+ 3;
 401   2            while(com[i]!= '\0')
 402   2            {
 403   3              coord[k]=com[i];
 404   3              i=i+1;
 405   3              k=k+1;
 406   3            }
 407   2            coord[i-1]='\0';
 408   2            commande.Angle=conv(coord,strlen(coord));
 409   2      
 410   2      
 411   2          }
 412   1          else
 413   1          {
 414   2            commande_correct=0;
 415   2          }
 416   1      
 417   1      
 418   1            return commande;
 419   1      
 420   1      }
 421          struct COMMANDES traitement_I(char * com, struct COMMANDES commande) // pas encore utilis�
 422          {
 423   1        // a compl�ter
 424   1        return commande;
 425   1      }
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 8   

*** WARNING C280 IN LINE 421 OF Src\main.c: 'com': unreferenced local variable
 426          struct COMMANDES traitement_M(char *com, struct COMMANDES commande)
 427          {
 428   1        int j;
 429   1        char tab[2];
 430   1        char angle;
 431   1        switch(com[1])
 432   1          {
 433   2              case 'I': //MI Mesure de courant
 434   2                commande.Etat_Energie=Mesure_I;
 435   2                break;
 436   2              case 'E': //ME Mesure de l'�nergie
 437   2                commande.Etat_Energie=Mesure_E;
 438   2                break;
 439   2              case 'O': //cas MO
 440   2                switch (com[2])
 441   2                {
 442   3                  case 'U': // cas MOU
 443   3                    commande.A_Obst=Obst_unique;
 444   3                    switch (com[4])
 445   3                    {
 446   4                      case 'D':
 447   4                        commande.Det=avant_arriere;//avant et arriere
 448   4                        break;
 449   4                      default:
 450   4                        commande.Det=avant;
 451   4                        //avant
 452   4                        break;
 453   4                    }
 454   3                    break;
 455   3                  case 'B': // cas MOB
 456   3                    commande.A_Obst=Obst_balayage;
 457   3                    switch(com[4])
 458   3                    {
 459   4                      case 'A':
 460   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 461   4                        for (j=6; j<8;j++)
 462   4                        {
 463   5                          tab[j-6]=com[j];
 464   5                        }
 465   4                        angle=conversioncoord(tab);
 466   4                        if (angle%5==0){
 467   5                          if(angle>=5 && angle<=45){
 468   6                            commande.DCT_Obst_Resolution=angle;
 469   6                            commande_correct=1;
 470   6                          }
 471   5                        }
 472   4                        else
 473   4                        {
 474   5                          commande_correct=0;
 475   5                        }
 476   4      
 477   4                        break;
 478   4                      case 'D':
 479   4                        commande.Etat_DCT_Obst=oui_180;
 480   4                        if (com[6]=='A')
 481   4                        {
 482   5                          for (j=8; j<10;j++)
 483   5                          {
 484   6                            tab[j-8]=com[j];
 485   6                          }
 486   5                          angle=conversioncoord(tab);
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 9   

 487   5                          if (angle%5==0){
 488   6                            if(angle>=5 && angle<=45){
 489   7                              commande.DCT_Obst_Resolution=angle;
 490   7                              commande_correct=1;
 491   7                            }
 492   6                          }
 493   5                          else
 494   5                          {
 495   6                            commande_correct=0;
 496   6                          }
 497   5                        }
 498   4      
 499   4                        else
 500   4                        {
 501   5                          commande.DCT_Obst_Resolution=30;
 502   5                        }
 503   4                        break;
 504   4                      default:
 505   4                        commande.Etat_DCT_Obst=oui_360;
 506   4                        commande.DCT_Obst_Resolution=30;
 507   4                        break;
 508   4                    }
 509   3                    break;
 510   3                  case 'S': // cas MOS
 511   3                    commande.A_Obst=Obst_proche_balayage;
 512   3                    switch(com[4])
 513   3                    {
 514   4                      case 'A':
 515   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 516   4                        for (j=6; j<8;j++)
 517   4                        {
 518   5                          tab[j-6]=com[j];
 519   5                        }
 520   4                        angle=conversioncoord(tab);
 521   4                        if (angle%5==0){
 522   5                          if(angle>=5 && angle<=45){
 523   6                            commande.DCT_Obst_Resolution=angle;
 524   6                            commande_correct=1;
 525   6                          }
 526   5                        }
 527   4                        else
 528   4                        {
 529   5                          commande_correct=0;
 530   5                        }
 531   4      
 532   4                        break;
 533   4                      case 'D':
 534   4                        commande.Etat_DCT_Obst=oui_180;
 535   4                        if (com[6]=='A')
 536   4                        {
 537   5                          for (j=8; j<10;j++)
 538   5                          {
 539   6                            tab[j-8]=com[j];
 540   6                          }
 541   5                          angle=conversioncoord(tab);
 542   5                          if (angle%5==0){
 543   6                            if(angle>=5 && angle<=45){
 544   7                              commande.DCT_Obst_Resolution=angle;
 545   7                              commande_correct=1;
 546   7                            }
 547   6                          }
 548   5                          else
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 10  

 549   5                          {
 550   6                            commande_correct=0;
 551   6                          }
 552   5                        }
 553   4      
 554   4                        else
 555   4                        {
 556   5                          commande.DCT_Obst_Resolution=30;
 557   5                        }
 558   4                        break;
 559   4                      default:
 560   4                        commande.Etat_DCT_Obst=oui_360;
 561   4                        commande.DCT_Obst_Resolution=30;
 562   4                        break;
 563   4                    }
 564   3                    break;
 565   3                  default:break;
 566   3                }
 567   2                break;
 568   2              }
 569   1            return commande;
 570   1      }
 571          struct COMMANDES traitement_P(char *com, struct COMMANDES commande) // PAS ENCORE UTILISE (POS)
 572          {
 573   1        // a compl�ter
 574   1        return commande;
 575   1      }
*** WARNING C280 IN LINE 571 OF Src\main.c: 'com': unreferenced local variable
 576          struct COMMANDES traitement_Q(struct COMMANDES commande) //ARRET DURGENCE
 577          {
 578   1        //serOutstring("arret d'urgence");
 579   1        commande.Etat_Epreuve=Stop_Urgence;
 580   1        return commande;
 581   1      }
 582          struct COMMANDES traitement_R(char * com, struct COMMANDES commande)// DIFFERENTES ROTATIONS OK
 583          {
 584   1        signed int angle;
 585   1        unsigned char tab[3];
 586   1        int j;
 587   1        switch (com[1])
 588   1            {
 589   2            case 'D': // si on recoit RD
 590   2            {
 591   3              commande.Etat_Mouvement=Rot_90D;
 592   3              break;
 593   3            }
 594   2            case 'G': //Si on recoit RG
 595   2            {
 596   3              commande.Etat_Mouvement=Rot_90G;
 597   3              break;
 598   3            }
 599   2            case 'C':// si on recoit RC
 600   2            {
 601   3              if (com[3]== 'D')
 602   3              {
 603   4                commande.Etat_Mouvement=Rot_180D;
 604   4                break;
 605   4              }
 606   3              if (com[3]== 'G')
 607   3              {
 608   4                commande.Etat_Mouvement=Rot_180G;
 609   4                break;
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 11  

 610   4              }
 611   3            }
 612   2            case 'A': // on recoit RA
 613   2            {
 614   3              switch (com[3])
 615   3              {
 616   4                case 'D':
 617   4                {
 618   5                  commande.Etat_Mouvement=Rot_AngD;
 619   5                  for (j=5; j<=7;j++)
 620   5                  {
 621   6                      tab[j-5]=com[j];
 622   6                  }
 623   5                  angle=conversionangle_positif(tab);
 624   5                  commande.Angle=angle;
 625   5                  break;
 626   5                }
 627   4                case 'G':
 628   4                {
 629   5                  commande.Etat_Mouvement=Rot_AngG;
 630   5                  for (j=5; j<=7;j++)
 631   5                  {
 632   6                      tab[j-5]=com[j];
 633   6                  }
 634   5                  angle=conversionangle_positif(tab);
 635   5                  commande.Angle=angle;
 636   5                  break;
 637   5                }
 638   4                default :
 639   4                {
 640   5                  commande.Etat_Mouvement=Rot_AngD;
 641   5                  angle=90;
 642   5                  commande.Angle=angle;
 643   5                  break;
 644   5                }
 645   4            }
 646   3            break;
 647   3          }
 648   2            default:
 649   2            {
 650   3              break;
 651   3            }
 652   2          }
 653   1          return commande;
 654   1      }
 655          struct COMMANDES traitement_S(char * com, struct COMMANDES commande/*,char f_b, char t_son, char t_silence
             -, char bip_b*/) // STOPPER
 656          {
 657   1        int i;
 658   1        char f_b=6;
 659   1        char t_son=25;
 660   1        char t_silence=50;
 661   1        char bip_b=3;
 662   1        char tab[2];
 663   1        char frequence;
 664   1        char duree_son;
 665   1        char duree_silence;
 666   1        char nombre_Bips;
 667   1      
 668   1        if( com[1]=='D')
 669   1        {
 670   2          commande.son=emission;
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 12  

 671   2            if(com[3]=='F')
 672   2            {
 673   3              for (i=5; i<7;i++)
 674   3              {
 675   4                tab[i-5]=com[i];
 676   4              }
 677   3              frequence=conversioncoord(tab);
 678   3              if (frequence >99 ||frequence <1)
 679   3              {
 680   4                  commande_correct = 0;
 681   4              }
 682   3              else
 683   3              {
 684   4                commande.frequence=frequence;
 685   4                commande_correct = 1;
 686   4              }
 687   3              for (i=10; i<12;i++)
 688   3              {
 689   4                tab[i-10]=com[i];
 690   4              }
 691   3              duree_son=conversioncoord(tab);
 692   3              if (duree_son >99 ||duree_son <1)
 693   3              {
 694   4                  commande_correct = 0;
 695   4              }
 696   3              else
 697   3              {
 698   4                commande.duree_son=duree_son;
 699   4                commande_correct = 1;
 700   4              }
 701   3              for (i=15; i<17;i++)
 702   3              {
 703   4                tab[i-15]=com[i];
 704   4              }
 705   3              duree_silence=conversioncoord(tab);
 706   3              if (duree_silence >99 ||duree_silence <1)
 707   3              {
 708   4                  commande_correct = 0;
 709   4              }
 710   3              else
 711   3              {
 712   4                commande.duree_silence=duree_silence;
 713   4                commande_correct = 1;
 714   4              }
 715   3              for (i=20; i<22;i++)
 716   3              {
 717   4                tab[i-20]=com[i];
 718   4              }
 719   3              nombre_Bips=conversioncoord(tab);
 720   3              if (nombre_Bips >99 ||nombre_Bips <1)
 721   3              {
 722   4                  commande_correct = 0;
 723   4              }
 724   3              else
 725   3              {
 726   4                commande.nombre_Bips=nombre_Bips;
 727   4                commande_correct = 1;
 728   4              }
 729   3      
 730   3            }
 731   2            else
 732   2            {
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 13  

 733   3              commande.frequence=f_b;               // d�finit par le code fr�quence allant de 1 a 99 (mais defini de 1
             - a 21)
 734   3              commande.duree_son=t_son;                 // dur�e du signal sonore
 735   3              commande.duree_silence=t_silence;             // duree du silence
 736   3              commande.nombre_Bips=bip_b;             // nombre de bips
 737   3            }
 738   2        }
 739   1        else
 740   1        {
 741   2          commande.Etat_Mouvement=Stopper;
 742   2        }
 743   1        return commande;
 744   1      }
 745          struct COMMANDES traitement_T(char * com, struct COMMANDES commande) // VITESSE A REGLER
 746          {
 747   1        char vitesse;
 748   1        char tab[3];
 749   1        int j;
 750   1        // on regarde le param�tre de la vitesse
 751   1      
 752   1        for (j=3; j<=5;j++)
 753   1        {
 754   2            tab[j-3]=com[j];
 755   2        }
 756   1        vitesse=conversionangle_positif(tab);
 757   1        j = ((int)vitesse& 0x00FF);
 758   1        if (j >= 100){
 759   2            commande_correct = 0;}
 760   1        else {
 761   2            vitesse_par_defaut=(vitesse & 0x00FF);
 762   2            strcpy(message_PC_com,"\r\n>");
 763   2            commande_correct = 2;
 764   2        }
 765   1        return commande;
 766   1      
 767   1      }
 768          
 769          struct COMMANDES Message (char * com/*, char f_b,char t_son,char t_silence,char bip_b*/){
 770   1      //  char tabcoordx[2];
 771   1      //  char tabcoordy[2];
 772   1      //  char tabangle[2];
 773   1      //  signed char coordx;
 774   1      //  signed char coordy;
 775   1      //  char angle;
 776   1      //  int cpt=0;
 777   1        //a modifier
 778   1      
 779   1      
 780   1      
 781   1        struct COMMANDES commande;
 782   1        commande.Etat_Epreuve = Epreuve_non;
 783   1        commande.Vitesse = vitesse_par_defaut;
 784   1        commande.Etat_Mouvement = Mouvement_non;
 785   1        commande.Etat_ACQ_Son = ACQ_non;
 786   1        commande.A_Obst = Non_obst;
 787   1        commande.Etat_DCT_Obst = DCT_non;
 788   1        commande.Etat_Lumiere = Lumiere_non;
 789   1        commande.Etat_Servo = Servo_non;
 790   1        commande.Etat_Energie = Energie_non;
 791   1        commande.Etat_Photo = Photo_non;
 792   1        commande.Etat_Position = Position_non;
 793   1        commande.son=non_emission;
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 14  

 794   1      
 795   1          switch (com[0])
 796   1          {
 797   2          case 'A':// si on recoit un A AVANCER OU DUREE DAQUISITION FIXEE
 798   2          {
 799   3            commande=traitement_A(com,commande);
 800   3            break;
 801   3          }
 802   2          case 'T':// si on recoit un TV Reglage de la vitesse seulement
 803   2          {
 804   3            commande=traitement_T(com,commande);
 805   3            break;
 806   3          }
 807   2          case 'D':// si on recoit un D (D�but de l'epreuve)
 808   2          {
 809   3            commande=traitement_D(com,commande);
 810   3            break;
 811   3          }
 812   2          case 'E':// si on recoit un E (fin de l'epreuve)
 813   2          {
 814   3            commande=traitement_E(commande);
 815   3            break;
 816   3      
 817   3          }
 818   2          case 'Q':// si on recoit un Q (arret d'urgence)
 819   2          {
 820   3            commande=traitement_Q(commande);
 821   3            break;
 822   3      
 823   3          }
 824   2          case 'M':// si on recoit un M (mesure et autre) PAS UTILISE
 825   2          {
 826   3            commande=traitement_M(com,commande);
 827   3            break;
 828   3          }
 829   2          case 'I':// si on recoit un IPO (I)
 830   2          {
 831   3            // a faire
 832   3            commande=traitement_I(com,commande);
 833   3            break;
 834   3          }
 835   2          case 'P':// si on recoit un POS
 836   2          {
 837   3            commande=traitement_P(com,commande);
 838   3            //envoie de information
 839   3            break;
 840   3      
 841   3          }
 842   2          case 'B': //si on recoit un B RECULER
 843   2          {
 844   3            commande=traitement_B(com,commande);
 845   3            break;
 846   3          }
 847   2          case 'S': // si on recoit S
 848   2          {
 849   3            commande=traitement_S(com, commande/*,f_b, t_son, t_silence, bip_b*/);
 850   3      
 851   3            break;
 852   3          }
 853   2          case 'G': // si on recoit G
 854   2          {
 855   3            commande=traitement_G(com,commande);
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 15  

 856   3            break;
 857   3          }
 858   2      
 859   2          case 'R': //Si On recoit R ROTATION
 860   2          {
 861   3            commande=traitement_R(com,commande);
 862   3            break;
 863   3          }
 864   2          case 'C':
 865   2            commande=traitement_C(com,commande);
 866   2            break;
 867   2          default:
 868   2          {
 869   3          commande_correct = 0;
 870   3          }
 871   2      }
 872   1      //}
 873   1      return commande;
 874   1      }
 875          
 876          
 877          
 878          void main (void)
 879          {
 880   1      //D�claration des variables
 881   1        //struct COMMANDES_SERIALIZER commande_serializer;
 882   1        struct COMMANDES commande;
 883   1        char message_s[50] = {0};
 884   1        char mess[6] = {0};
 885   1        char echo[3] = {0};
 886   1        char com[50] = {0};
 887   1      //  char nbr[10];
 888   1        char a;
 889   1        char i =0;
 890   1        int b = 0;
 891   1        unsigned char code_err = 0;
 892   1      
 893   1        //a modifier
 894   1        char f_b=6;
 895   1        char t_son=25;
 896   1        char t_silence=50;
 897   1        char bip_b=3;
 898   1      
 899   1        EA=0;
 900   1        Init_Device();  // Initialisation du microcontr�leur
 901   1        Config_Timer2();
 902   1        Config_timer0();
 903   1        Config_Timer3();
 904   1        Config_SPI_MASTER();
 905   1        CFG_VREF();
 906   1        CFG_ADC0();
 907   1        CFG_Clock_UART();
 908   1        cfg_UART0_mode1();
 909   1        init_Serial_Buffer();
 910   1        init_Serial_Buffer1();
 911   1        CFG_UART1();
 912   1        NSS_slave = 1;
 913   1        TR2 = 0;
 914   1        energie = 0;
 915   1        EA=1;
 916   1      
 917   1      
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 16  

 918   1        //Courant_ADC();
 919   1        //fonctionRoutage(commande);
 920   1      
 921   1        serOutstring("\n\rDemarrage robot\n\r>");
 922   1      // a commenter si le robot est d�ja allum� avant le lancement du code
 923   1      // Pour recevoir le message de d�marrage du serializer
 924   1      /*  do{
 925   1            a=serInchar1();
 926   1            echo[0] = a;
 927   1            echo[1] = '\0';
 928   1            serOutstring(echo);
 929   1            memset(echo,0,strlen(echo));
 930   1          }while(a!=0x3E);
 931   1      */
 932   1        while(1){
 933   2      
 934   2          memset(message_s,0,sizeof(message_s));
 935   2          memset(mess, 0, strlen(mess));
 936   2          memset(message_PC_com, 0, strlen(message_PC_com));
 937   2      
 938   2          commande_correct =1;
 939   2      
 940   2          i=0;
 941   2          a=0;
 942   2          memset(com, 0, 50);
 943   2          /*do{
 944   2            a=serInchar();
 945   2            echo[0] = a;
 946   2            echo[1] = '\0';
 947   2            serOutstring(echo);
 948   2            memset(echo,0,strlen(echo));
 949   2            if (a!=0x00)
 950   2              {
 951   2              com[i]=a;
 952   2              i=i+1;
 953   2              }
 954   2            }while(a!=0x0D); Commenté pour les tests avec le simulateur*/
 955   2      
 956   2          //strcpy(com,"CS V A:-90");
 957   2          //strcpy(com,"SD F:12 P:50 W:60 B:5");
 958   2          //strcpy(com,"MOB");
 959   2      
 960   2          commande = Message(com/*, f_b, t_son, t_silence, bip_b*/);
 961   2            /*if(commande.son==emission)
 962   2            {
 963   2              f_b=commande.frequence;
 964   2              t_son=commande.duree_son;
 965   2              t_silence=commande.duree_silence;
 966   2              bip_b=commande.nombre_Bips;
 967   2            }*/
 968   2          if (commande_correct == 1){
 969   3              fonctionRoutage(commande);
 970   3          }
 971   2          if (commande_correct == 2){
 972   3            serOutstring(message_PC_com); // si erreur
 973   3          }
 974   2          if(commande_correct == 0){
 975   3            strcpy(mess, "\n\r#\n\r>");
 976   3            serOutstring(mess); // si erreur
 977   3          }
 978   2        //serOutstring(message_PC_com); // si erreur
 979   2        }
C51 COMPILER V9.51   MAIN                                                                  05/19/2018 16:14:50 PAGE 17  

 980   1      
 981   1      }
 982          
 983          void ISR_Timer2 (void) interrupt 5 {
 984   1        TF2 = 0; //Remise � '0' du flag d'overflow
 985   1        PWM_servo=!PWM_servo; //On envoie le signal PWM au servomoteur
 986   1      }
 987          
 988          void ISR_Timer3 (void) interrupt 14 {
 989   1        TMR3CN &= 0x04; //Remise � '0' du flag d'overflow
 990   1        energie += 9.6*Courant_ADC()*0.001*0.035;
 991   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5452    ----
   CONSTANT SIZE    =    375    ----
   XDATA SIZE       =     59     782
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
