C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Src\main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) TABS(2) OBJECT
                    -(main.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "Declarations_GPIO.h"
   7          #include "Config_Globale.h"
   8          #include "Timers.h"
   9          #include "Servomoteur_Horizontal.h"
  10          #include "ultrason.h"
  11          #include "Config_SPI.h"
  12          #include "Transmission_SPI.h"
  13          #include "Config_ADC.h"
  14          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  15          #include "UART0_RingBuffer_lib.h"
  16          #include "ConfigUART1.h"
  17          #include "UART0_RingBuffer_lib.h"
  18          #include "Fonctions_cote_serializer.h"
  19          #include "Lien_Structure_commande.h"
  20          #include "Mesure_courant.h"
  21          
  22          #ifndef CFG_Globale
  23            #define CFG_Globale
  24            #include "CFG_Globale.h"
  25          #endif
  26          
  27          
  28          //------------------------------------------------------------------------------------
  29          // D�clarations des variables globales
  30          //------------------------------------------------------------------------------------
  31          int vitesse_par_defaut = 10;
  32          char message_PC_com[50] = {0};
  33          enum Epreuve epreuve_en_cours = Epreuve_non;
  34          int commande_correct = 0;
  35          double energie = 0;
  36          unsigned int courant = 0;
  37          
  38          char conversioncoord (unsigned char tableau[2]){
  39   1        int dizaine=0;
  40   1        int unite=0;
  41   1        char valeur;
  42   1      
  43   1        dizaine= (tableau[0]-'0')*10;
  44   1        unite= (tableau[1]-'0');
  45   1      
  46   1        valeur=dizaine+unite;
  47   1        return valeur ;
  48   1      }
  49          
  50          /*char conversionvitesse (unsigned char tableau[3]){
  51            int centaine=0;
  52            int dizaine=0;
  53            int unite=0;
  54            char valeur;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 2   

  55          
  56            centaine= (tableau[0]-'0')*100;
  57            dizaine= (tableau[1]-'0')*10;
  58            unite= (tableau[2]-'0');
  59          
  60            valeur= centaine+dizaine+unite;
  61            return valeur ;
  62          }*/
  63          
  64          signed int conv(char* nbr, int taille)
  65          {
  66   1        int k=0;
  67   1        double t1 = 0;
  68   1        signed int ret=0;
  69   1        int numero=0;
  70   1      
  71   1        if(nbr[0]=='-')
  72   1        {
  73   2          for(k=1;k<taille;k++)
  74   2          {
  75   3            numero=nbr[k]-'0';
  76   3            t1 = pow(10,taille-1-k);
  77   3            numero = numero*ceil(pow(10,taille-1-k));
  78   3            ret+=numero;
  79   3          }
  80   2          ret=-1*ret;
  81   2        }
  82   1        else
  83   1        {
  84   2          for(k=0;k<taille;k++)
  85   2          {
  86   3            numero=(nbr[k]-'0')*ceil(pow(10,taille-1-k));
  87   3            ret+=numero;
  88   3          }
  89   2        }
  90   1        return ret;
  91   1      }
  92          signed int conversionangle_positif (unsigned char tableau[3]){
  93   1        signed int centaine=0;
  94   1        signed int dizaine=0;
  95   1        signed int unite=0;
  96   1        signed int valeur;
  97   1      
  98   1        if (tableau[0] == '-') {
  99   2          dizaine= (tableau[1]-'0')*10;
 100   2          unite= (tableau[2]-'0');
 101   2          valeur = -1* (dizaine + unite);
 102   2        }
 103   1        else {
 104   2          centaine= (tableau[0]-'0')*100;
 105   2          dizaine= (tableau[1]-'0')*10;
 106   2          unite= (tableau[2]-'0');
 107   2          valeur= centaine+dizaine+unite;
 108   2        }
 109   1        return valeur ;
 110   1      }
 111          
 112          struct COMMANDES traitement_A(char * com, struct COMMANDES commande){ // traitement lorsque la premi�re 
             -lettre est A (AVANCER A DUREE DAQUISITION) AVANCER OK
 113   1        char vitesse;
 114   1        char tab[3];
 115   1        int j;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 3   

 116   1        char duree;
 117   1      
 118   1        switch (com[1]) //AJOUTER LA DUREE
 119   1            {
 120   2              case 'S': // cas ASS (Dur�e)
 121   2                {
 122   3                  commande_correct = 0; //TODO commande_correct = nbr pour aquisition signal
 123   3                  for (j=4; j<7;j++)
 124   3                    {
 125   4                    tab[j-4]=com[j];
 126   4                  }
 127   3                  duree=conversionangle_positif(tab);
 128   3                  if (duree >= 100 ||duree <1)
 129   3                    {
 130   4                    commande_correct = 0;
 131   4                  }
 132   3                  else{commande.ACQ_Duree=duree;}
 133   3                  break;
 134   3              }
 135   2              case ' ':// cas d'avancer A
 136   2              {
 137   3                if (epreuve_en_cours == epreuve1){
 138   4                  commande.Etat_Mouvement=Avancer;
 139   4                  // on regarde le param�tre de la vitesse
 140   4                  if (com[2] >= 0x30)
 141   4                  {
 142   5                    for (j=2; j<5;j++)
 143   5                      {
 144   6                        tab[j-2]=com[j];
 145   6                    }
 146   5                    vitesse=conversionangle_positif(tab);
 147   5                  if (vitesse >= 100 ||vitesse <=0)
 148   5                    {
 149   6                      commande_correct = 0;
 150   6                    }
 151   5                  else
 152   5                    {
 153   6                    commande.Vitesse=vitesse;
 154   6                    commande_correct = 1; // nbr 1 pour routage vers le serializer
 155   6      
 156   6                    }}
 157   4                  else{ commande_correct = 1; // nbr 1 pour routage vers le serializer
 158   5                  }
 159   4                }
 160   3                    else {
 161   4                      commande_correct = 2;
 162   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 163   3                break;
 164   3              }
 165   2            default:
 166   2              {
 167   3              if (epreuve_en_cours == epreuve1){
 168   4                commande.Etat_Mouvement=Avancer;
 169   4                commande_correct = 1;}
 170   3                else{
 171   4                      commande_correct = 2;
 172   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 173   3            }
 174   2          }
 175   1          return commande;
 176   1      }
 177          struct COMMANDES traitement_B(char* com, struct COMMANDES commande) // RECULER OK
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 4   

 178          {
 179   1        char vitesse;
 180   1        char tab[3];
 181   1        int j;
 182   1        commande.Etat_Mouvement=Reculer;
 183   1            if (com[1]==' ')
 184   1              {
 185   2              for (j=2; j<=4;j++)
 186   2              {
 187   3                  tab[j-2]=com[j];
 188   3              }
 189   2              vitesse=conversionangle_positif(tab);
 190   2                if (vitesse >= 100 ||vitesse <0)
 191   2                  {
 192   3                    commande_correct = 0;
 193   3                  }
 194   2                else
 195   2                  {
 196   3                  commande.Vitesse=vitesse;
 197   3                  commande_correct = 1;
 198   3                  }
 199   2              }
 200   1      
 201   1            else {
 202   2                  commande_correct = 1;
 203   2            }
 204   1      
 205   1            return commande;
 206   1      }
 207          struct COMMANDES traitement_C(char* com, struct COMMANDES commande) // pilotage du servomoteur
 208          {
 209   1        signed int angle;
 210   1        unsigned char tab[3];
 211   1        int j=0;
 212   1        switch (com[3])
 213   1        {
 214   2          case 'H':
 215   2          {
 216   3            commande.Etat_Servo=Servo_H;
 217   3            if (com[5]=='A')
 218   3              {
 219   4              for (j=7; j<10;j++)
 220   4                {
 221   5                    tab[j-7]=com[j];
 222   5                }
 223   4              angle=conversionangle_positif(tab);
 224   4                if (angle > 90 ||angle <-90)
 225   4                {
 226   5                  commande_correct = 0;
 227   5                }
 228   4                else
 229   4                {
 230   5                  commande.Servo_Angle=angle;
 231   5                  commande_correct = 1;
 232   5                }
 233   4            }
 234   3            else
 235   3            {
 236   4              angle=0;
 237   4            }
 238   3            commande.Servo_Angle=angle;
 239   3            break;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 5   

 240   3          }
 241   2          case 'V':
 242   2          {
 243   3            commande.Etat_Servo=Servo_V;
 244   3            if (com[5]=='A')
 245   3              {
 246   4              for (j=7; j<10;j++)
 247   4                {
 248   5                    tab[j-7]=com[j];
 249   5                }
 250   4              angle=conversionangle_positif(tab);
 251   4                if (angle > 90 ||angle <-90)
 252   4                {
 253   5                  commande_correct = 0;
 254   5                }
 255   4                else
 256   4                {
 257   5                  commande.Servo_Angle=angle;
 258   5                  commande_correct = 1;
 259   5                }
 260   4            }
 261   3      
 262   3            else
 263   3            {
 264   4              angle=0;
 265   4              commande.Servo_Angle=angle;
 266   4            }
 267   3      
 268   3            break;
 269   3          }
 270   2          default:
 271   2          {
 272   3            commande.Etat_Servo=Servo_H;
 273   3            angle=0;
 274   3            commande.Servo_Angle=angle;
 275   3            break;
 276   3          }
 277   2        }
 278   1        return commande;
 279   1      }
 280          struct COMMANDES traitement_D(char * com, struct COMMANDES commande)// DEBUT DEPREUVE OK
 281          {
 282   1        switch (com[2]) // exemple message:  D 1
 283   1            {
 284   2              case '1': //�preuve 1
 285   2              {
 286   3                commande.Etat_Epreuve=epreuve1;
 287   3                strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 288   3                epreuve_en_cours = epreuve1;
 289   3                //serOutstring("Invite de commande 1");
 290   3                break;
 291   3      
 292   3              }
 293   2              case '2': //�preuve 2
 294   2              {
 295   3                commande.Etat_Epreuve=epreuve2;
 296   3                strcpy(message_PC_com, "\r\nInvite de commande 2\r\n>");
 297   3                epreuve_en_cours = epreuve2;
 298   3                //serOutstring("Invite de commande 2");
 299   3                break;
 300   3      
 301   3              }
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 6   

 302   2              case '3': //�preuve 3
 303   2              {
 304   3                commande.Etat_Epreuve=epreuve3;
 305   3                epreuve_en_cours = epreuve3;
 306   3                strcpy(message_PC_com, "\r\nInvite de commande 3\r\n>");
 307   3                //serOutstring("Invite de commande 3");
 308   3                break;
 309   3      
 310   3              }
 311   2              case '4': //�preuve 4
 312   2              {
 313   3                commande.Etat_Epreuve=epreuve4;
 314   3                epreuve_en_cours = epreuve4;
 315   3                strcpy(message_PC_com, "\r\nInvite de commande 4\r\n>");
 316   3                //serOutstring("Invite de commande 4");
 317   3                break;
 318   3      
 319   3              }
 320   2              case '5': //�preuve 5
 321   2              {
 322   3                commande.Etat_Epreuve=epreuve5;
 323   3                epreuve_en_cours = epreuve5;
 324   3                strcpy(message_PC_com, "\r\nInvite de commande 5\r\n>");
 325   3                //serOutstring("Invite de commande 5");
 326   3                break;
 327   3              }
 328   2              case '6': //�preuve 6
 329   2              {
 330   3                commande.Etat_Epreuve=epreuve6;
 331   3                epreuve_en_cours = epreuve6;
 332   3                strcpy(message_PC_com, "\r\nInvite de commande 6\r\n>");
 333   3                //serOutstring("Invite de commande 6");
 334   3                break;
 335   3      
 336   3              }
 337   2              case '7': //�preuve 7
 338   2              {
 339   3                commande.Etat_Epreuve=epreuve7;
 340   3                epreuve_en_cours = epreuve7;
 341   3                strcpy(message_PC_com, "\r\nInvite de commande 7\r\n>");
 342   3                //serOutstring("Invite de commande 7");
 343   3                break;
 344   3              }
 345   2              case '8': //�preuve 8
 346   2              {
 347   3                commande.Etat_Epreuve=epreuve8;
 348   3                epreuve_en_cours = epreuve8;
 349   3                strcpy(message_PC_com, "\r\nInvite de commande 8\r\n>");
 350   3                //serOutstring("Invite de commande 8");
 351   3                break;
 352   3              }
 353   2              default:
 354   2              {
 355   3              commande.Etat_Epreuve=epreuve1;
 356   3                epreuve_en_cours = epreuve1;
 357   3              strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 358   3              //serOutstring("Invite de commande 1");
 359   3      
 360   3              }
 361   2            }
 362   1            commande_correct = 2;
 363   1            return commande;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 7   

 364   1      }
 365          struct COMMANDES traitement_E(struct COMMANDES commande)//FIN DEPREUVE OK
 366          {
 367   1        //serOutstring("Fin de l'�preuve");
 368   1        commande.Etat_Epreuve=Epreuve_non;
 369   1        commande.Etat_Mouvement =Mouvement_non;
 370   1        epreuve_en_cours = Epreuve_non;
 371   1        return commande;
 372   1      }
 373          struct COMMANDES traitement_G(char * com, struct COMMANDES commande) // DEPLACEMENT AVEC ANGLE : OK
 374          {
 375   1          int i=4;
 376   1          int k=0;
 377   1          char coord[10];
 378   1          if (epreuve_en_cours == epreuve1 && com[1]==' ' && com[2]=='X' && com[3]==':')
 379   1          {
 380   2            commande.Etat_Mouvement = Depl_Coord;
 381   2      
 382   2            while(com[i]!= ' ')
 383   2            {
 384   3              coord[k]=com[i];
 385   3              i=i+1;
 386   3              k++;
 387   3            }
 388   2            coord[k]='\0';
 389   2            commande.Coord_X=conv(coord,strlen(coord));
 390   2            i = i+ 3;
 391   2            k=0;
 392   2            while(com[i]!= ' ')
 393   2            {
 394   3              coord[k]=com[i];
 395   3              i=i+1;
 396   3              k=k+1;
 397   3            }
 398   2            coord[i]='\0';
 399   2            commande.Coord_Y=conv(coord,strlen(coord));
 400   2            k=0;
 401   2            i = i+ 3;
 402   2            while(com[i]!= '\0')
 403   2            {
 404   3              coord[k]=com[i];
 405   3              i=i+1;
 406   3              k=k+1;
 407   3            }
 408   2            coord[i-1]='\0';
 409   2            commande.Angle=conv(coord,strlen(coord));
 410   2      
 411   2      
 412   2          }
 413   1          else
 414   1          {
 415   2            commande_correct=0;
 416   2          }
 417   1      
 418   1      
 419   1            return commande;
 420   1      
 421   1      }
 422          
 423          /*struct COMMANDES traitement_I(char * com, struct COMMANDES commande) // pas encore utilis�
 424          {
 425            // a compl�ter
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 8   

 426            return commande;
 427          }*/
 428          struct COMMANDES traitement_M(char *com, struct COMMANDES commande)
 429          {
 430   1        int j;
 431   1        char tab[2];
 432   1        char angle;
 433   1        switch(com[1])
 434   1          {
 435   2              case 'I': //MI Mesure de courant
 436   2                commande.Etat_Energie=Mesure_I;
 437   2                break;
 438   2              case 'E': //ME Mesure de l'�nergie
 439   2                commande.Etat_Energie=Mesure_E;
 440   2                break;
 441   2              case 'O': //cas MO
 442   2                switch (com[2])
 443   2                {
 444   3                  case 'U': // cas MOU
 445   3                    commande.A_Obst=Obst_unique;
 446   3                    switch (com[4])
 447   3                    {
 448   4                      case 'D':
 449   4                        commande.Det=avant_arriere;//avant et arriere
 450   4                        break;
 451   4                      default:
 452   4                        commande.Det=avant;
 453   4                        //avant
 454   4                        break;
 455   4                    }
 456   3                    break;
 457   3                  case 'B': // cas MOB
 458   3                    commande.A_Obst=Obst_balayage;
 459   3                    switch(com[4])
 460   3                    {
 461   4                      case 'A':
 462   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 463   4                        for (j=6; j<8;j++)
 464   4                        {
 465   5                          tab[j-6]=com[j];
 466   5                        }
 467   4                        angle=conversioncoord(tab);
 468   4                        if (angle%5==0){
 469   5                          if(angle>=5 && angle<=45){
 470   6                            commande.DCT_Obst_Resolution=angle;
 471   6                            commande_correct=1;
 472   6                          }
 473   5                        }
 474   4                        else
 475   4                        {
 476   5                          commande_correct=0;
 477   5                        }
 478   4      
 479   4                        break;
 480   4                      case 'D':
 481   4                        commande.Etat_DCT_Obst=oui_180;
 482   4                        if (com[6]=='A')
 483   4                        {
 484   5                          for (j=8; j<10;j++)
 485   5                          {
 486   6                            tab[j-8]=com[j];
 487   6                          }
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 9   

 488   5                          angle=conversioncoord(tab);
 489   5                          if (angle%5==0){
 490   6                            if(angle>=5 && angle<=45){
 491   7                              commande.DCT_Obst_Resolution=angle;
 492   7                              commande_correct=1;
 493   7                            }
 494   6                          }
 495   5                          else
 496   5                          {
 497   6                            commande_correct=0;
 498   6                          }
 499   5                        }
 500   4      
 501   4                        else
 502   4                        {
 503   5                          commande.DCT_Obst_Resolution=30;
 504   5                        }
 505   4                        break;
 506   4                      default:
 507   4                        commande.Etat_DCT_Obst=oui_360;
 508   4                        commande.DCT_Obst_Resolution=30;
 509   4                        break;
 510   4                    }
 511   3                    break;
 512   3                  case 'S': // cas MOS
 513   3                    commande.A_Obst=Obst_proche_balayage;
 514   3                    switch(com[4])
 515   3                    {
 516   4                      case 'A':
 517   4                        commande.Etat_DCT_Obst=oui_360; // d�fault de D
 518   4                        for (j=6; j<8;j++)
 519   4                        {
 520   5                          tab[j-6]=com[j];
 521   5                        }
 522   4                        angle=conversioncoord(tab);
 523   4                        if (angle%5==0){
 524   5                          if(angle>=5 && angle<=45){
 525   6                            commande.DCT_Obst_Resolution=angle;
 526   6                            commande_correct=1;
 527   6                          }
 528   5                        }
 529   4                        else
 530   4                        {
 531   5                          commande_correct=0;
 532   5                        }
 533   4      
 534   4                        break;
 535   4                      case 'D':
 536   4                        commande.Etat_DCT_Obst=oui_180;
 537   4                        if (com[6]=='A')
 538   4                        {
 539   5                          for (j=8; j<10;j++)
 540   5                          {
 541   6                            tab[j-8]=com[j];
 542   6                          }
 543   5                          angle=conversioncoord(tab);
 544   5                          if (angle%5==0){
 545   6                            if(angle>=5 && angle<=45){
 546   7                              commande.DCT_Obst_Resolution=angle;
 547   7                              commande_correct=1;
 548   7                            }
 549   6                          }
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 10  

 550   5                          else
 551   5                          {
 552   6                            commande_correct=0;
 553   6                          }
 554   5                        }
 555   4      
 556   4                        else
 557   4                        {
 558   5                          commande.DCT_Obst_Resolution=30;
 559   5                        }
 560   4                        break;
 561   4                      default:
 562   4                        commande.Etat_DCT_Obst=oui_360;
 563   4                        commande.DCT_Obst_Resolution=30;
 564   4                        break;
 565   4                    }
 566   3                    break;
 567   3                  default:break;
 568   3                }
 569   2                break;
 570   2              }
 571   1            return commande;
 572   1      }
 573          /*struct COMMANDES traitement_P(char *com, struct COMMANDES commande) // PAS ENCORE UTILISE (POS)
 574          {
 575            // a compl�ter
 576            return commande;
 577          }*/
 578          struct COMMANDES traitement_Q(struct COMMANDES commande) //ARRET DURGENCE
 579          {
 580   1        //serOutstring("arret d'urgence");
 581   1        commande.Etat_Epreuve=Stop_Urgence;
 582   1        return commande;
 583   1      }
 584          struct COMMANDES traitement_R(char * com, struct COMMANDES commande)// DIFFERENTES ROTATIONS OK
 585          {
 586   1        signed int angle;
 587   1        unsigned char tab[3];
 588   1        int j;
 589   1        switch (com[1])
 590   1            {
 591   2            case 'D': // si on recoit RD
 592   2            {
 593   3              commande.Etat_Mouvement=Rot_90D;
 594   3              break;
 595   3            }
 596   2            case 'G': //Si on recoit RG
 597   2            {
 598   3              commande.Etat_Mouvement=Rot_90G;
 599   3              break;
 600   3            }
 601   2            case 'C':// si on recoit RC
 602   2            {
 603   3              if (com[3]== 'D')
 604   3              {
 605   4                commande.Etat_Mouvement=Rot_180D;
 606   4                break;
 607   4              }
 608   3              if (com[3]== 'G')
 609   3              {
 610   4                commande.Etat_Mouvement=Rot_180G;
 611   4                break;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 11  

 612   4              }
 613   3            }
 614   2            case 'A': // on recoit RA
 615   2            {
 616   3              switch (com[3])
 617   3              {
 618   4                case 'D':
 619   4                {
 620   5                  commande.Etat_Mouvement=Rot_AngD;
 621   5                  for (j=5; j<=7;j++)
 622   5                  {
 623   6                      tab[j-5]=com[j];
 624   6                  }
 625   5                  angle=conversionangle_positif(tab);
 626   5                  commande.Angle=angle;
 627   5                  break;
 628   5                }
 629   4                case 'G':
 630   4                {
 631   5                  commande.Etat_Mouvement=Rot_AngG;
 632   5                  for (j=5; j<=7;j++)
 633   5                  {
 634   6                      tab[j-5]=com[j];
 635   6                  }
 636   5                  angle=conversionangle_positif(tab);
 637   5                  commande.Angle=angle;
 638   5                  break;
 639   5                }
 640   4                default :
 641   4                {
 642   5                  commande.Etat_Mouvement=Rot_AngD;
 643   5                  angle=90;
 644   5                  commande.Angle=angle;
 645   5                  break;
 646   5                }
 647   4            }
 648   3            break;
 649   3          }
 650   2            default:
 651   2            {
 652   3              break;
 653   3            }
 654   2          }
 655   1          return commande;
 656   1      }
 657          struct COMMANDES traitement_S(char * com, struct COMMANDES commande/*,char f_b, char t_son, char t_silence
             -, char bip_b*/) // STOPPER
 658          {
 659   1        int i;
 660   1        char f_b=6;
 661   1        char t_son=25;
 662   1        char t_silence=50;
 663   1        char bip_b=3;
 664   1        char tab[2];
 665   1        char frequence;
 666   1        char duree_son;
 667   1        char duree_silence;
 668   1        char nombre_Bips;
 669   1      
 670   1        if( com[1]=='D')
 671   1        {
 672   2          commande.son=emission;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 12  

 673   2            if(com[3]=='F')
 674   2            {
 675   3              for (i=5; i<7;i++)
 676   3              {
 677   4                tab[i-5]=com[i];
 678   4              }
 679   3              frequence=conversioncoord(tab);
 680   3              if (frequence >99 ||frequence <1)
 681   3              {
 682   4                  commande_correct = 0;
 683   4              }
 684   3              else
 685   3              {
 686   4                commande.frequence=frequence;
 687   4                commande_correct = 1;
 688   4              }
 689   3              for (i=10; i<12;i++)
 690   3              {
 691   4                tab[i-10]=com[i];
 692   4              }
 693   3              duree_son=conversioncoord(tab);
 694   3              if (duree_son >99 ||duree_son <1)
 695   3              {
 696   4                  commande_correct = 0;
 697   4              }
 698   3              else
 699   3              {
 700   4                commande.duree_son=duree_son;
 701   4                commande_correct = 1;
 702   4              }
 703   3              for (i=15; i<17;i++)
 704   3              {
 705   4                tab[i-15]=com[i];
 706   4              }
 707   3              duree_silence=conversioncoord(tab);
 708   3              if (duree_silence >99 ||duree_silence <1)
 709   3              {
 710   4                  commande_correct = 0;
 711   4              }
 712   3              else
 713   3              {
 714   4                commande.duree_silence=duree_silence;
 715   4                commande_correct = 1;
 716   4              }
 717   3              for (i=20; i<22;i++)
 718   3              {
 719   4                tab[i-20]=com[i];
 720   4              }
 721   3              nombre_Bips=conversioncoord(tab);
 722   3              if (nombre_Bips >99 ||nombre_Bips <1)
 723   3              {
 724   4                  commande_correct = 0;
 725   4              }
 726   3              else
 727   3              {
 728   4                commande.nombre_Bips=nombre_Bips;
 729   4                commande_correct = 1;
 730   4              }
 731   3      
 732   3            }
 733   2            else
 734   2            {
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 13  

 735   3              commande.frequence=f_b;               // d�finit par le code fr�quence allant de 1 a 99 (mais defini de 1
             - a 21)
 736   3              commande.duree_son=t_son;                 // dur�e du signal sonore
 737   3              commande.duree_silence=t_silence;             // duree du silence
 738   3              commande.nombre_Bips=bip_b;             // nombre de bips
 739   3            }
 740   2        }
 741   1        else
 742   1        {
 743   2          commande.Etat_Mouvement=Stopper;
 744   2        }
 745   1        return commande;
 746   1      }
 747          struct COMMANDES traitement_T(char * com, struct COMMANDES commande) // VITESSE A REGLER
 748          {
 749   1        char vitesse;
 750   1        char tab[3];
 751   1        int j;
 752   1        // on regarde le param�tre de la vitesse
 753   1      
 754   1        for (j=3; j<=5;j++)
 755   1        {
 756   2            tab[j-3]=com[j];
 757   2        }
 758   1        vitesse=conversionangle_positif(tab);
 759   1        j = ((int)vitesse& 0x00FF);
 760   1        if (j >= 100){
 761   2            commande_correct = 0;}
 762   1        else {
 763   2            vitesse_par_defaut=(vitesse & 0x00FF);
 764   2            strcpy(message_PC_com,"\r\n>");
 765   2            commande_correct = 2;
 766   2        }
 767   1        return commande;
 768   1      
 769   1      }
 770          
 771          struct COMMANDES Message (char * com/*, char f_b,char t_son,char t_silence,char bip_b*/){
 772   1      //  char tabcoordx[2];
 773   1      //  char tabcoordy[2];
 774   1      //  char tabangle[2];
 775   1      //  signed char coordx;
 776   1      //  signed char coordy;
 777   1      //  char angle;
 778   1      //  int cpt=0;
 779   1        //a modifier
 780   1      
 781   1      
 782   1      
 783   1        struct COMMANDES commande;
 784   1        commande.Etat_Epreuve = Epreuve_non;
 785   1        commande.Vitesse = vitesse_par_defaut;
 786   1        commande.Etat_Mouvement = Mouvement_non;
 787   1        commande.Etat_ACQ_Son = ACQ_non;
 788   1        commande.A_Obst = Non_obst;
 789   1        commande.Etat_DCT_Obst = DCT_non;
 790   1        commande.Etat_Lumiere = Lumiere_non;
 791   1        commande.Etat_Servo = Servo_non;
 792   1        commande.Etat_Energie = Energie_non;
 793   1        commande.Etat_Photo = Photo_non;
 794   1        commande.Etat_Position = Position_non;
 795   1        commande.son=non_emission;
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 14  

 796   1      
 797   1          switch (com[0])
 798   1          {
 799   2          case 'A':// si on recoit un A AVANCER OU DUREE DAQUISITION FIXEE
 800   2          {
 801   3            commande=traitement_A(com,commande);
 802   3            break;
 803   3          }
 804   2          case 'T':// si on recoit un TV Reglage de la vitesse seulement
 805   2          {
 806   3            commande=traitement_T(com,commande);
 807   3            break;
 808   3          }
 809   2          case 'D':// si on recoit un D (D�but de l'epreuve)
 810   2          {
 811   3            commande=traitement_D(com,commande);
 812   3            break;
 813   3          }
 814   2          case 'E':// si on recoit un E (fin de l'epreuve)
 815   2          {
 816   3            commande=traitement_E(commande);
 817   3            break;
 818   3      
 819   3          }
 820   2          case 'Q':// si on recoit un Q (arret d'urgence)
 821   2          {
 822   3            commande=traitement_Q(commande);
 823   3            break;
 824   3      
 825   3          }
 826   2          case 'M':// si on recoit un M (mesure et autre) PAS UTILISE
 827   2          {
 828   3            commande=traitement_M(com,commande);
 829   3            break;
 830   3          }
 831   2          case 'I':// si on recoit un IPO (I)
 832   2          {
 833   3            // a faire
 834   3            //commande=traitement_I(com,commande);
 835   3            break;
 836   3          }
 837   2          case 'P':// si on recoit un POS
 838   2          {
 839   3            //commande=traitement_P(com,commande);
 840   3            //envoie de information
 841   3            break;
 842   3      
 843   3          }
 844   2          case 'B': //si on recoit un B RECULER
 845   2          {
 846   3            commande=traitement_B(com,commande);
 847   3            break;
 848   3          }
 849   2          case 'S': // si on recoit S
 850   2          {
 851   3            commande=traitement_S(com, commande/*,f_b, t_son, t_silence, bip_b*/);
 852   3      
 853   3            break;
 854   3          }
 855   2          case 'G': // si on recoit G
 856   2          {
 857   3            commande=traitement_G(com,commande);
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 15  

 858   3            break;
 859   3          }
 860   2      
 861   2          case 'R': //Si On recoit R ROTATION
 862   2          {
 863   3            commande=traitement_R(com,commande);
 864   3            break;
 865   3          }
 866   2          case 'C':
 867   2            commande=traitement_C(com,commande);
 868   2            break;
 869   2          default:
 870   2          {
 871   3          commande_correct = 0;
 872   3          }
 873   2      }
 874   1      //}
 875   1      return commande;
 876   1      }
 877          
 878          
 879          
 880          void main (void)
 881          {
 882   1      //D�claration des variables
 883   1        //struct COMMANDES_SERIALIZER commande_serializer;
 884   1        struct COMMANDES commande;
 885   1        char message_s[50] = {0};
 886   1        char mess[6] = {0};
 887   1        char echo[3] = {0};
 888   1        char com[50] = {0};
 889   1      //  char nbr[10];
 890   1        char a;
 891   1        char i =0;
 892   1        int b = 0;
 893   1        unsigned char code_err = 0;
 894   1      
 895   1        //a modifier
 896   1        char f_b=6;
 897   1        char t_son=25;
 898   1        char t_silence=50;
 899   1        char bip_b=3;
 900   1      
 901   1        EA=0;
 902   1        Init_Device();  // Initialisation du microcontr�leur
 903   1        Config_Timer2();
 904   1        Config_timer0();
 905   1        Config_Timer3();
 906   1        Config_SPI_MASTER();
 907   1        CFG_VREF();
 908   1        CFG_ADC0();
 909   1        CFG_Clock_UART();
 910   1        cfg_UART0_mode1();
 911   1        init_Serial_Buffer();
 912   1        init_Serial_Buffer1();
 913   1        CFG_UART1();
 914   1        NSS_slave = 1;
 915   1        TR2 = 0;
 916   1        energie = 0;
 917   1        EA=1;
 918   1      
 919   1        serOutstring("\n\rDemarrage robot\n\r>");
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 16  

 920   1      // a commenter si le robot est d�ja allum� avant le lancement du code
 921   1      // Pour recevoir le message de d�marrage du serializer
 922   1      /*  do{
 923   1            a=serInchar1();
 924   1            echo[0] = a;
 925   1            echo[1] = '\0';
 926   1            serOutstring(echo);
 927   1            memset(echo,0,strlen(echo));
 928   1          }while(a!=0x3E);
 929   1      */
 930   1        while(1){
 931   2      
 932   2          memset(message_s,0,sizeof(message_s));
 933   2          memset(mess, 0, strlen(mess));
 934   2          memset(message_PC_com, 0, strlen(message_PC_com));
 935   2      
 936   2          commande_correct =1;
 937   2      
 938   2          i=0;
 939   2          a=0;
 940   2          memset(com, 0, 50);
 941   2          do{
 942   3            a=serInchar();
 943   3            echo[0] = a;
 944   3            echo[1] = '\0';
 945   3            serOutstring(echo);
 946   3            memset(echo,0,strlen(echo));
 947   3            if (a!=0x00)
 948   3              {
 949   4              com[i]=a;
 950   4              i=i+1;
 951   4              }
 952   3            }while(a!=0x0D); //Commenté pour les tests avec le simulateur
 953   2      
 954   2          //strcpy(com,"CS V A:-45");
 955   2          //strcpy(com,"SD F:12 P:50 W:60 B:05");
 956   2          //strcpy(com,"MOB");
 957   2      
 958   2          commande = Message(com);
 959   2            
 960   2          if (commande_correct == 1){
 961   3              fonctionRoutage(commande);
 962   3          }
 963   2          if (commande_correct == 2){
 964   3            serOutstring(message_PC_com); // si erreur
 965   3          }
 966   2          if(commande_correct == 0){
 967   3            strcpy(mess, "\n\r#\n\r>");
 968   3            serOutstring(mess); // si erreur
 969   3          }
 970   2        //serOutstring(message_PC_com); // si erreur
 971   2        }
 972   1      
 973   1      }
 974          
 975          void ISR_Timer2 (void) interrupt 5 {
 976   1        TF2 = 0; //Remise � '0' du flag d'overflow
 977   1        PWM_servo=!PWM_servo; //On envoie le signal PWM au servomoteur
 978   1      }
 979          
 980          void ISR_Timer3 (void) interrupt 14 {
 981   1        TMR3CN &= 0x04; //Remise � '0' du flag d'overflow
C51 COMPILER V9.51   MAIN                                                                  05/22/2018 19:07:47 PAGE 17  

 982   1        courant = Courant_ADC();
 983   1        energie += 9.6*courant*0.001*0.035;
 984   1        
 985   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5445    ----
   CONSTANT SIZE    =    375    ----
   XDATA SIZE       =     61     715
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
