C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h> 
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "Declarations_GPIO.h"
   7          #include "Config_Globale.h"
   8          #include "Timers.h"
   9          #include "Servomoteur_Horizontal.h"
  10          #include "ultrason.h"
  11          #include "Config_SPI.h"
  12          #include "Transmission_SPI.h"
  13          #include "ADC.h"
  14          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  15          #include "UART0_RingBuffer_lib.h"
  16          #include "ConfigUART1.h"
  17          #include "UART0_RingBuffer_lib.h"
  18          #include "Fonctions_cote_serializer.h"
  19          #include "Lien_Structure_commande.h"
  20          
  21          #ifndef CFG_Globale
  22            #define CFG_Globale
  23            #include <CFG_Globale.h>
  24          #endif
  25          
  26          
  27          //------------------------------------------------------------------------------------
  28          // Déclarations des variables globales
  29          //------------------------------------------------------------------------------------
  30          int vitesse_par_defaut = 10;
  31          char message_PC_com[50] = {0};
  32          enum Epreuve epreuve_en_cours = Epreuve_non;
  33          int commande_correct = 0;
  34          
  35          char conversioncoord (unsigned char tableau[2]){
  36   1        int dizaine=0;
  37   1        int unite=0; 
  38   1        char valeur;
  39   1        
  40   1        dizaine= (tableau[0]-'0')*10;
  41   1        unite= (tableau[1]-'0');
  42   1        
  43   1        valeur=dizaine+unite;
  44   1        return valeur ;
  45   1      }
  46          
  47          /*char conversionvitesse (unsigned char tableau[3]){
  48            int centaine=0;
  49            int dizaine=0;
  50            int unite=0; 
  51            char valeur;
  52            
  53            centaine= (tableau[0]-'0')*100;
  54            dizaine= (tableau[1]-'0')*10;
  55            unite= (tableau[2]-'0');
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 2   

  56            
  57            valeur= centaine+dizaine+unite;
  58            return valeur ;
  59          }*/
  60          
  61          signed int conversionangle_positif (unsigned char tableau[3]){ 
  62   1        signed int centaine=0;
  63   1        signed int dizaine=0;
  64   1        signed int unite=0; 
  65   1        signed int valeur;
  66   1        
  67   1        centaine= (tableau[0]-'0')*100;
  68   1        dizaine= (tableau[1]-'0')*10;
  69   1        unite= (tableau[2]-'0');
  70   1      
  71   1        valeur= centaine+dizaine+unite;
  72   1        return valeur ;
  73   1      }
  74          
  75          struct COMMANDES traitement_A(char * com, struct COMMANDES commande){ // traitement lorsque la première le
             -ttre est A (AVANCER A DUREE DAQUISITION) AVANCER OK
  76   1        char vitesse;
  77   1        char tab[3];
  78   1        int j;  
  79   1        char duree;
  80   1      
  81   1        switch (com[1]) //AJOUTER LA DUREE
  82   1            {
  83   2              case 'S': // cas ASS (Durée) 
  84   2                {
  85   3                  commande_correct = 0; //TODO commande_correct = nbr pour aquisition signal
  86   3                  for (j=4; j<7;j++)
  87   3                    {
  88   4                    tab[j-4]=com[j];
  89   4                  }
  90   3                  duree=conversionangle_positif(tab);
  91   3                  if (duree >= 100 ||duree <1)
  92   3                    {           
  93   4                    commande_correct = 0;
  94   4                  }
  95   3                  else{commande.ACQ_Duree=duree;}
  96   3                  break;
  97   3              }
  98   2              case ' ':// cas d'avancer A
  99   2              {
 100   3                if (epreuve_en_cours == epreuve1){
 101   4                  commande.Etat_Mouvement=Avancer;
 102   4                  // on regarde le paramètre de la vitesse
 103   4                  if (com[2] >= 0x30)
 104   4                  {
 105   5                    for (j=2; j<5;j++)
 106   5                      {
 107   6                        tab[j-2]=com[j];
 108   6                    }
 109   5                    vitesse=conversionangle_positif(tab);
 110   5                  if (vitesse >= 100 ||vitesse <=0)
 111   5                    {
 112   6                      commande_correct = 0;
 113   6                    }
 114   5                  else
 115   5                    {
 116   6                    commande.Vitesse=vitesse;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 3   

 117   6                    commande_correct = 1; // nbr 1 pour routage vers le serializer
 118   6      
 119   6                    }}
 120   4                  else{ commande_correct = 1; // nbr 1 pour routage vers le serializer
 121   5                  }
 122   4                }
 123   3                    else {
 124   4                      commande_correct = 2;
 125   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 126   3                break;
 127   3              }
 128   2            default:
 129   2              { 
 130   3              if (epreuve_en_cours == epreuve1){
 131   4                commande.Etat_Mouvement=Avancer;
 132   4                commande_correct = 1;}
 133   3                else{
 134   4                      commande_correct = 2;
 135   4                      strcpy(message_PC_com,"\r\nErreur non epreuve 1\r\n>");}
 136   3            }
 137   2          }
 138   1          return commande;
 139   1      }
 140          struct COMMANDES traitement_B(char* com, struct COMMANDES commande) // RECULER OK
 141          {
 142   1        char vitesse;
 143   1        char tab[3];
 144   1        int j;
 145   1        commande.Etat_Mouvement=Reculer;
 146   1            if (com[1]==' ')
 147   1              {
 148   2              for (j=2; j<=4;j++)
 149   2              {
 150   3                  tab[j-2]=com[j];
 151   3              }
 152   2              vitesse=conversionangle_positif(tab);
 153   2                if (vitesse >= 100 ||vitesse <0)
 154   2                  {
 155   3                    commande_correct = 0;
 156   3                  }
 157   2                else
 158   2                  {
 159   3                  commande.Vitesse=vitesse;
 160   3                  commande_correct = 1;
 161   3                  }
 162   2              }
 163   1            
 164   1            else {
 165   2                  commande_correct = 1;
 166   2            }
 167   1      
 168   1            return commande;
 169   1      }
 170          struct COMMANDES traitement_C(char* com, struct COMMANDES commande) // pilotage du servomoteur
 171          {
 172   1        signed int angle;
 173   1        unsigned char tab[3];
 174   1        int j=0;
 175   1        switch (com[3])
 176   1        {
 177   2          case 'H':
 178   2          {
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 4   

 179   3            commande.Etat_Servo=Servo_H;
 180   3            if (com[5]=='A')
 181   3              {
 182   4              for (j=7; j<10;j++)
 183   4                {
 184   5                    tab[j-7]=com[j];
 185   5                }
 186   4              angle=conversionangle_positif(tab);
 187   4                if (angle > 90 ||angle <-90)
 188   4                {
 189   5                  commande_correct = 0;
 190   5                }
 191   4                else
 192   4                {
 193   5                  commande.Servo_Angle=angle;
 194   5                  commande_correct = 1;
 195   5                }
 196   4            }
 197   3            else
 198   3            {
 199   4              angle=0;
 200   4            }
 201   3            commande.Servo_Angle=angle;
 202   3            break;
 203   3          }
 204   2          case 'V':
 205   2          {
 206   3            commande.Etat_Servo=Servo_V;
 207   3            if (com[5]=='A')
 208   3              {
 209   4              for (j=7; j<10;j++)
 210   4                {
 211   5                    tab[j-7]=com[j];
 212   5                }
 213   4              angle=conversionangle_positif(tab);
 214   4                if (angle > 90 ||angle <-90)
 215   4                {
 216   5                  commande_correct = 0;
 217   5                }
 218   4                else
 219   4                {
 220   5                  commande.Servo_Angle=angle;
 221   5                  commande_correct = 1;
 222   5                }
 223   4            }
 224   3            
 225   3            else
 226   3            {
 227   4              angle=0;
 228   4              commande.Servo_Angle=angle;
 229   4            }
 230   3            
 231   3            break;
 232   3          }
 233   2          default:
 234   2          {
 235   3            commande.Etat_Servo=Servo_H;
 236   3            angle=0;
 237   3            commande.Servo_Angle=angle;
 238   3            break;
 239   3          }
 240   2        }
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 5   

 241   1        return commande;
 242   1      }
 243          struct COMMANDES traitement_D(char * com, struct COMMANDES commande)// DEBUT DEPREUVE OK
 244          {
 245   1        switch (com[2]) // exemple message:  D 1 
 246   1            {
 247   2              case '1': //épreuve 1
 248   2              {
 249   3                commande.Etat_Epreuve=epreuve1;
 250   3                strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 251   3                epreuve_en_cours = epreuve1;
 252   3                //serOutstring("Invite de commande 1");
 253   3                break;
 254   3      
 255   3              }
 256   2              case '2': //épreuve 2
 257   2              {
 258   3                commande.Etat_Epreuve=epreuve2;
 259   3                strcpy(message_PC_com, "\r\nInvite de commande 2\r\n>");
 260   3                epreuve_en_cours = epreuve2;
 261   3                //serOutstring("Invite de commande 2");
 262   3                break;
 263   3      
 264   3              }
 265   2              case '3': //épreuve 3
 266   2              {
 267   3                commande.Etat_Epreuve=epreuve3;
 268   3                epreuve_en_cours = epreuve3;
 269   3                strcpy(message_PC_com, "\r\nInvite de commande 3\r\n>");
 270   3                //serOutstring("Invite de commande 3");
 271   3                break;
 272   3      
 273   3              }
 274   2              case '4': //épreuve 4
 275   2              {
 276   3                commande.Etat_Epreuve=epreuve4;
 277   3                epreuve_en_cours = epreuve4;
 278   3                strcpy(message_PC_com, "\r\nInvite de commande 4\r\n>");
 279   3                //serOutstring("Invite de commande 4");
 280   3                break;
 281   3      
 282   3              }
 283   2              case '5': //épreuve 5
 284   2              {
 285   3                commande.Etat_Epreuve=epreuve5;
 286   3                epreuve_en_cours = epreuve5;
 287   3                strcpy(message_PC_com, "\r\nInvite de commande 5\r\n>");
 288   3                //serOutstring("Invite de commande 5");
 289   3                break;
 290   3              }
 291   2              case '6': //épreuve 6
 292   2              {
 293   3                commande.Etat_Epreuve=epreuve6;
 294   3                epreuve_en_cours = epreuve6;
 295   3                strcpy(message_PC_com, "\r\nInvite de commande 6\r\n>");
 296   3                //serOutstring("Invite de commande 6");
 297   3                break;
 298   3      
 299   3              }
 300   2              case '7': //épreuve 7
 301   2              {
 302   3                commande.Etat_Epreuve=epreuve7;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 6   

 303   3                epreuve_en_cours = epreuve7;
 304   3                strcpy(message_PC_com, "\r\nInvite de commande 7\r\n>");
 305   3                //serOutstring("Invite de commande 7");
 306   3                break;
 307   3              }
 308   2              case '8': //épreuve 8
 309   2              {
 310   3                commande.Etat_Epreuve=epreuve8;
 311   3                epreuve_en_cours = epreuve8;
 312   3                strcpy(message_PC_com, "\r\nInvite de commande 8\r\n>");
 313   3                //serOutstring("Invite de commande 8");
 314   3                break;
 315   3              }
 316   2              default:
 317   2              {
 318   3              commande.Etat_Epreuve=epreuve1;
 319   3                epreuve_en_cours = epreuve1;
 320   3              strcpy(message_PC_com, "\r\nInvite de commande 1\r\n>");
 321   3              //serOutstring("Invite de commande 1");
 322   3      
 323   3              }
 324   2            }
 325   1            commande_correct = 2;
 326   1            return commande;
 327   1      }
 328          struct COMMANDES traitement_E(struct COMMANDES commande)//FIN DEPREUVE OK
 329          {
 330   1        //serOutstring("Fin de l'épreuve");
 331   1        commande.Etat_Epreuve=Epreuve_non;
 332   1        commande.Etat_Mouvement =Mouvement_non;
 333   1        epreuve_en_cours = Epreuve_non;
 334   1        return commande;
 335   1      }
 336          struct COMMANDES traitement_G(char * com, struct COMMANDES commande) // DEPLACEMENT AVEC ANGLE : OK
 337          {
 338   1        
 339   1        int cpt=0;
 340   1        int bin=1;
 341   1        signed int angle;
 342   1        int signe_angle=0; // positif si 0 négatif si 1
 343   1        int signe_x=0; // positif si 0 négatif si 1
 344   1        int signe_y=0; // positif si 0 négatif si 1
 345   1        int k;
 346   1        signed char coordx;
 347   1        signed char coordy;
 348   1        char tabcoordx[2];
 349   1        char tabcoordy[2];  
 350   1        unsigned char tabangle[3];  
 351   1        commande.Etat_Mouvement=Depl_Coord;
 352   1      
 353   1            for(k=0;k<=50;k++)
 354   1            {
 355   2              bin=1;
 356   2              if (com[k]==':' && cpt==0 && bin==1)
 357   2              {
 358   3                
 359   3                  if (com[k+1]=='-')
 360   3                  { 
 361   4                    tabcoordx[0]=com[k+2];
 362   4                    tabcoordx[1]=com[k+3];
 363   4                    
 364   4                    coordx=conversioncoord(tabcoordx);
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 7   

 365   4                    coordx=coordx;
 366   4                    signe_x=1;
 367   4                    cpt=cpt+1;
 368   4                    bin=0;
 369   4                    
 370   4                  }
 371   3                  else
 372   3                  {
 373   4                    tabcoordx[0]=com[k+1];
 374   4                    tabcoordx[1]=com[k+2];
 375   4                    coordx=conversioncoord(tabcoordx);
 376   4                    cpt=cpt+1;
 377   4                    bin=0;
 378   4                  }
 379   3                }
 380   2                if (com[k]==':' && cpt==1 && bin==1)
 381   2                  {
 382   3                    if (com[k+1]=='-')
 383   3                    {
 384   4                      
 385   4                      tabcoordy[0]=com[k+2];
 386   4                      tabcoordy[1]=com[k+3];
 387   4                      coordy=conversioncoord(tabcoordy);
 388   4                      coordy=coordy;
 389   4                      signe_y=1;
 390   4                      cpt=cpt+1;
 391   4                      bin=0;
 392   4                    }
 393   3                    else
 394   3                    {
 395   4                      tabcoordy[0]=com[k+1];
 396   4                      tabcoordy[1]=com[k+2];
 397   4                      coordy=conversioncoord(tabcoordy);
 398   4                      cpt=cpt+1;
 399   4                      bin=0;
 400   4                    }
 401   3                }
 402   2                if (com[k]==':' && cpt==2 && bin==1)
 403   2                {
 404   3                  if (com[k+1] =='-')
 405   3                  {
 406   4                  tabangle[0]=com[k+2]; // saut du signe -
 407   4                  tabangle[1]=com[k+3];
 408   4                  tabangle[2]=com[k+4];
 409   4                  signe_angle=1;
 410   4                  angle=conversionangle_positif(tabangle);
 411   4                  }
 412   3                  else
 413   3                  {
 414   4                  tabangle[0]=com[k+1];
 415   4                  tabangle[1]=com[k+2];
 416   4                  tabangle[2]=com[k+3];
 417   4                  angle=conversionangle_positif(tabangle);
 418   4                  }
 419   3                  // DEMANDER A THibaut comment il traite G 
 420   3                  switch (signe_angle)
 421   3                  {
 422   4                    case 1: // cas angle négatif selon le sens trigonométrique
 423   4                      {
 424   5                        if (signe_x==1 && signe_y==0)
 425   5                        {
 426   6                          angle=-angle;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 8   

 427   6                          //commande.Etat_Mouvement=Rot_AngG;
 428   6                        }
 429   5                        if (signe_x==1 && signe_y==1)
 430   5                        {
 431   6                          angle=180-angle;
 432   6                          //commande.Etat_Mouvement=Rot_AngG;
 433   6                        }
 434   5                        bin=0;
 435   5                        if (signe_x==0 && signe_y==1)
 436   5                        {
 437   6                          angle=-(180-angle);
 438   6                          //commande.Etat_Mouvement=Rot_AngD;
 439   6      
 440   6                        }
 441   5                        break;
 442   5                      }
 443   4                    default:// cas angle positif selon le sens trigonométrique
 444   4                    {
 445   5                      if (signe_x==1 && signe_y==0)
 446   5                        {
 447   6                          angle=-angle;
 448   6                        }
 449   5                      if (signe_x==1 && signe_y==1)
 450   5                        {
 451   6                          //commande.Etat_Mouvement=Rot_AngD;
 452   6                          angle=-(180-angle);
 453   6                        }
 454   5                      if (signe_x==0 && signe_y==1)
 455   5                        {
 456   6                          //commande.Etat_Mouvement=Rot_AngG;
 457   6                          angle=180-angle;
 458   6                        }
 459   5                      break;
 460   5                    }
 461   4                  }
 462   3                  bin=0;
 463   3                }
 464   2            }
 465   1          commande.Coord_X=coordx;
 466   1          commande.Coord_Y=coordy;
 467   1          commande.Angle=angle;
 468   1          return commande;
 469   1      }
 470          struct COMMANDES traitement_I(char * com, struct COMMANDES commande) // pas encore utilisé
 471          {
 472   1        // a compléter
 473   1        return commande;
 474   1      }
*** WARNING C280 IN LINE 470 OF main.c: 'com': unreferenced local variable
 475          struct COMMANDES traitement_M(char *com, struct COMMANDES commande) 
 476          {
 477   1        int j;
 478   1        char tab[2];
 479   1        char angle;
 480   1        switch(com[1])
 481   1          {
 482   2              case 'I': //MI Mesure de courant
 483   2                commande.Etat_Energie=Mesure_I;
 484   2                break;
 485   2              case 'E': //ME Mesure de l'énergie
 486   2                commande.Etat_Energie=Mesure_E;
 487   2                break;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 9   

 488   2              case 'O': //cas MO
 489   2                switch (com[2])
 490   2                {
 491   3                  case 'U': // cas MOU 
 492   3                    commande.A_Obst=Obst_unique;
 493   3                    switch (com[4])
 494   3                    {
 495   4                      case 'D':
 496   4                        commande.Det=avant_arriere;//avant et arriere
 497   4                        break;
 498   4                      default:
 499   4                        commande.Det=avant;
 500   4                        //avant
 501   4                        break;
 502   4                    }
 503   3                    break;
 504   3                  case 'B': // cas MOB 
 505   3                    commande.A_Obst=Obst_balayage;
 506   3                    switch(com[4])
 507   3                    {
 508   4                      case 'A':
 509   4                        commande.Etat_DCT_Obst=oui_360; // défault de D
 510   4                        for (j=6; j<8;j++)
 511   4                        {
 512   5                          tab[j-6]=com[j];
 513   5                        }
 514   4                        angle=conversioncoord(tab);
 515   4                        if (angle%5==0 && (angle>5 || angle<45))
 516   4                        {
 517   5                          commande.DCT_Obst_Resolution=angle;
 518   5                          commande_correct=1;
 519   5                        }
 520   4                        else
 521   4                        {
 522   5                          commande_correct=0;
 523   5                        }
 524   4                        
 525   4                        break;
 526   4                      case 'D':
 527   4                        commande.Etat_DCT_Obst=oui_180;
 528   4                        if (com[6]=='A')
 529   4                        {
 530   5                          for (j=8; j<10;j++)
 531   5                          {
 532   6                            tab[j-8]=com[j];
 533   6                          }
 534   5                          angle=conversioncoord(tab);
 535   5                          if (angle%5==0 && (angle>5 || angle<45))
 536   5                          {
 537   6                          commande.DCT_Obst_Resolution=angle;
 538   6                          commande_correct=1;
 539   6                          }
 540   5                          else
 541   5                          {
 542   6                            commande_correct=0;
 543   6                          }
 544   5                        }
 545   4                          
 546   4                        else
 547   4                        {
 548   5                          commande.DCT_Obst_Resolution=30;
 549   5                        }
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 10  

 550   4                        break;
 551   4                      default:
 552   4                        commande.Etat_DCT_Obst=oui_360;
 553   4                        commande.DCT_Obst_Resolution=30;
 554   4                        break;
 555   4                    } 
 556   3                  case 'S': // cas MOS 
 557   3                    commande.A_Obst=Obst_balayage;
 558   3                    switch(com[4])
 559   3                    {
 560   4                      case 'A':
 561   4                        commande.Etat_DCT_Obst=oui_360; // défault de D
 562   4                        for (j=6; j<8;j++)
 563   4                        {
 564   5                          tab[j-6]=com[j];
 565   5                        }
 566   4                        angle=conversioncoord(tab);
 567   4                        if (angle%5==0 && (angle>5 || angle<45))
 568   4                        {
 569   5                          commande.DCT_Obst_Resolution=angle;
 570   5                          commande_correct=1;
 571   5                        }
 572   4                        else
 573   4                        {
 574   5                          commande_correct=0;
 575   5                        }
 576   4                        
 577   4                        break;
 578   4                      case 'D':
 579   4                        commande.Etat_DCT_Obst=oui_180;
 580   4                        if (com[6]=='A')
 581   4                        {
 582   5                          for (j=8; j<10;j++)
 583   5                          {
 584   6                            tab[j-8]=com[j];
 585   6                          }
 586   5                          angle=conversioncoord(tab);
 587   5                          if ((angle%5==0) && (angle>=5) && (angle<=45))
 588   5                          {
 589   6                            commande.DCT_Obst_Resolution=angle;
 590   6                            commande_correct=1;
 591   6                          }
 592   5                          else
 593   5                          {
 594   6                            commande_correct=0;
 595   6                          }
 596   5                        }
 597   4                          
 598   4                        else
 599   4                        {
 600   5                          commande.DCT_Obst_Resolution=30;
 601   5                        }
 602   4                        break;
 603   4                      default:
 604   4                        commande.Etat_DCT_Obst=oui_360;
 605   4                        commande.DCT_Obst_Resolution=30;
 606   4                        break;
 607   4                    } 
 608   3                    break;
 609   3                  default:break;
 610   3                }
 611   2                break;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 11  

 612   2              }
 613   1            return commande;
 614   1      }
 615          struct COMMANDES traitement_P(char *com, struct COMMANDES commande) // PAS ENCORE UTILISE (POS)
 616          {
 617   1        // a compléter
 618   1        return commande;
 619   1      }
*** WARNING C280 IN LINE 615 OF main.c: 'com': unreferenced local variable
 620          struct COMMANDES traitement_Q(struct COMMANDES commande) //ARRET DURGENCE 
 621          {
 622   1        //serOutstring("arret d'urgence");
 623   1        commande.Etat_Epreuve=Stop_Urgence;
 624   1        return commande;
 625   1      }
 626          struct COMMANDES traitement_R(char * com, struct COMMANDES commande)// DIFFERENTES ROTATIONS OK
 627          {
 628   1        signed int angle;
 629   1        unsigned char tab[3];
 630   1        int j;
 631   1        switch (com[1])
 632   1            {
 633   2            case 'D': // si on recoit RD
 634   2            {
 635   3              commande.Etat_Mouvement=Rot_90D;
 636   3              break;
 637   3            }
 638   2            case 'G': //Si on recoit RG
 639   2            {
 640   3              commande.Etat_Mouvement=Rot_90G;  
 641   3              break;
 642   3            }
 643   2            case 'C':// si on recoit RC
 644   2            {
 645   3              if (com[3]== 'D')
 646   3              {
 647   4                commande.Etat_Mouvement=Rot_180D; 
 648   4                break;
 649   4              }
 650   3              if (com[3]== 'G')
 651   3              {
 652   4                commande.Etat_Mouvement=Rot_180G; 
 653   4                break;
 654   4              }
 655   3            }
 656   2            case 'A': // on recoit RA
 657   2            {
 658   3              switch (com[3])
 659   3              {
 660   4                case 'D':
 661   4                {
 662   5                  commande.Etat_Mouvement=Rot_AngD; 
 663   5                  for (j=5; j<=7;j++)
 664   5                  {
 665   6                      tab[j-5]=com[j];
 666   6                  }
 667   5                  angle=conversionangle_positif(tab);
 668   5                  commande.Angle=angle;
 669   5                  break;
 670   5                }
 671   4                case 'G':
 672   4                {
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 12  

 673   5                  commande.Etat_Mouvement=Rot_AngG;
 674   5                  for (j=5; j<=7;j++)
 675   5                  {
 676   6                      tab[j-5]=com[j];
 677   6                  }
 678   5                  angle=conversionangle_positif(tab);
 679   5                  commande.Angle=angle;
 680   5                  break;
 681   5                }
 682   4                default :
 683   4                {
 684   5                  commande.Etat_Mouvement=Rot_AngD; 
 685   5                  angle=90;
 686   5                  commande.Angle=angle;
 687   5                  break;
 688   5                }
 689   4            }
 690   3            break;
 691   3          }
 692   2            default:
 693   2            {
 694   3              break;
 695   3            }
 696   2          }
 697   1          return commande;
 698   1      }
 699          struct COMMANDES traitement_S(char * com, struct COMMANDES commande/*,char f_b, char t_son, char t_silence
             -, char bip_b*/) // STOPPER
 700          {
 701   1        int i;
 702   1        char f_b=6;
 703   1        char t_son=25;
 704   1        char t_silence=50;
 705   1        char bip_b=3;
 706   1        char tab[2];
 707   1        char frequence;
 708   1        char duree_son;
 709   1        char duree_silence;
 710   1        char nombre_Bips;
 711   1        
 712   1        if( com[1]=='D')
 713   1        {
 714   2          commande.son=emission;
 715   2            if(com[3]=='F')
 716   2            {
 717   3              for (i=5; i<7;i++)
 718   3              {
 719   4                tab[i-5]=com[i];
 720   4              }
 721   3              frequence=conversioncoord(tab);
 722   3              if (frequence >99 ||frequence <1)
 723   3              {
 724   4                  commande_correct = 0;
 725   4              }
 726   3              else
 727   3              {
 728   4                commande.frequence=frequence;
 729   4                commande_correct = 1;
 730   4              }
 731   3              for (i=10; i<12;i++)
 732   3              {
 733   4                tab[i-10]=com[i];
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 13  

 734   4              }
 735   3              duree_son=conversioncoord(tab);
 736   3              if (duree_son >99 ||duree_son <1)
 737   3              {
 738   4                  commande_correct = 0;
 739   4              }
 740   3              else
 741   3              {
 742   4                commande.duree_son=duree_son;
 743   4                commande_correct = 1;
 744   4              }
 745   3              for (i=15; i<17;i++)
 746   3              {
 747   4                tab[i-15]=com[i];
 748   4              }
 749   3              duree_silence=conversioncoord(tab);
 750   3              if (duree_silence >99 ||duree_silence <1)
 751   3              {
 752   4                  commande_correct = 0;
 753   4              }
 754   3              else
 755   3              {
 756   4                commande.duree_silence=duree_silence;
 757   4                commande_correct = 1;
 758   4              }
 759   3              for (i=20; i<22;i++)
 760   3              {
 761   4                tab[i-20]=com[i];
 762   4              }
 763   3              nombre_Bips=conversioncoord(tab);
 764   3              if (nombre_Bips >99 ||nombre_Bips <1)
 765   3              {
 766   4                  commande_correct = 0;
 767   4              }
 768   3              else
 769   3              {
 770   4                commande.nombre_Bips=nombre_Bips;
 771   4                commande_correct = 1;
 772   4              }
 773   3              
 774   3            }
 775   2            else
 776   2            {
 777   3              commande.frequence=f_b;               // définit par le code fréquence allant de 1 a 99 (mais defini de 1 a 2
             -1)
 778   3              commande.duree_son=t_son;                 // durée du signal sonore
 779   3              commande.duree_silence=t_silence;             // duree du silence
 780   3              commande.nombre_Bips=bip_b;             // nombre de bips
 781   3            }
 782   2        }
 783   1        else
 784   1        {
 785   2          commande.Etat_Mouvement=Stopper;  
 786   2        }
 787   1        return commande;
 788   1      }
 789          struct COMMANDES traitement_T(char * com, struct COMMANDES commande) // VITESSE A REGLER
 790          {
 791   1        char vitesse;
 792   1        char tab[3];
 793   1        int j;
 794   1        // on regarde le paramètre de la vitesse
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 14  

 795   1            
 796   1        for (j=3; j<=5;j++)
 797   1        {
 798   2            tab[j-3]=com[j];
 799   2        } 
 800   1        vitesse=conversionangle_positif(tab);
 801   1        j = ((int)vitesse& 0x00FF);
 802   1        if (j >= 100){
 803   2            commande_correct = 0;}
 804   1        else {
 805   2            vitesse_par_defaut=(vitesse & 0x00FF);
 806   2            strcpy(message_PC_com,"\r\n>");
 807   2            commande_correct = 2;
 808   2        }
 809   1        return commande;
 810   1        
 811   1      }
 812          
 813          struct COMMANDES Message (char * com, char f_b,char t_son,char t_silence,char bip_b){
 814   1      //  char tabcoordx[2];
 815   1      //  char tabcoordy[2];  
 816   1      //  char tabangle[2]; 
 817   1      //  signed char coordx;
 818   1      //  signed char coordy;
 819   1      //  char angle;
 820   1      //  int cpt=0;
 821   1        //a modifier
 822   1      
 823   1        
 824   1      
 825   1        struct COMMANDES commande;
 826   1        commande.Etat_Epreuve = Epreuve_non;
 827   1        commande.Vitesse = vitesse_par_defaut;
 828   1        commande.Etat_Mouvement = Mouvement_non;
 829   1        commande.Etat_ACQ_Son = ACQ_non;
 830   1        commande.A_Obst = Non_obst;
 831   1        commande.Etat_DCT_Obst = DCT_non;
 832   1        commande.Etat_Lumiere = Lumiere_non;
 833   1        commande.Etat_Servo = Servo_non;
 834   1        commande.Etat_Energie = Energie_non;
 835   1        commande.Etat_Photo = Photo_non;
 836   1        commande.Etat_Position = Position_non;
 837   1        commande.son=non_emission;
 838   1        
 839   1          switch (com[0])
 840   1          {
 841   2          case 'A':// si on recoit un A AVANCER OU DUREE DAQUISITION FIXEE
 842   2          {
 843   3            commande=traitement_A(com,commande);
 844   3            break;
 845   3          }
 846   2          case 'T':// si on recoit un TV Reglage de la vitesse seulement
 847   2          {
 848   3            commande=traitement_T(com,commande);
 849   3            break;
 850   3          }
 851   2          case 'D':// si on recoit un D (Début de l'epreuve)
 852   2          {
 853   3            commande=traitement_D(com,commande);
 854   3            break;
 855   3          }
 856   2          case 'E':// si on recoit un E (fin de l'epreuve)
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 15  

 857   2          {
 858   3            commande=traitement_E(commande);
 859   3            break;
 860   3      
 861   3          }
 862   2          case 'Q':// si on recoit un Q (arret d'urgence)
 863   2          {
 864   3            commande=traitement_Q(commande);
 865   3            break;
 866   3      
 867   3          }
 868   2          case 'M':// si on recoit un M (mesure et autre) PAS UTILISE 
 869   2          {
 870   3            commande=traitement_M(com,commande);
 871   3            break;
 872   3          }
 873   2          case 'I':// si on recoit un IPO (I)
 874   2          {
 875   3            // a faire
 876   3            commande=traitement_I(com,commande);
 877   3            break;
 878   3          }
 879   2          case 'P':// si on recoit un POS 
 880   2          {
 881   3            commande=traitement_P(com,commande);
 882   3            //envoie de information
 883   3            break;
 884   3      
 885   3          }
 886   2          case 'B': //si on recoit un B RECULER
 887   2          {
 888   3            commande=traitement_B(com,commande);
 889   3            break;
 890   3          }
 891   2          case 'S': // si on recoit S
 892   2          {
 893   3            commande=traitement_S(com/*, commande,f_b, t_son, t_silence, bip_b*/);
*** WARNING C209 IN LINE 893 OF main.c: '_traitement_S': too few actual parameters
 894   3      
 895   3            break;
 896   3          }
 897   2          case 'G': // si on recoit G
 898   2          {
 899   3            commande=traitement_G(com,commande);
 900   3            break;
 901   3          }
 902   2          
 903   2          case 'R': //Si On recoit R ROTATION
 904   2          {
 905   3            commande=traitement_R(com,commande);
 906   3            break;
 907   3          }
 908   2          case 'C':
 909   2            commande=traitement_C(com,commande);
 910   2            break;
 911   2          default:
 912   2          {
 913   3          commande_correct = 0;
 914   3          }
 915   2      }
 916   1      //}
 917   1      return commande;
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 16  

 918   1      }
*** WARNING C280 IN LINE 813 OF main.c: 'f_b': unreferenced local variable
*** WARNING C280 IN LINE 813 OF main.c: 't_son': unreferenced local variable
*** WARNING C280 IN LINE 813 OF main.c: 't_silence': unreferenced local variable
*** WARNING C280 IN LINE 813 OF main.c: 'bip_b': unreferenced local variable
 919          
 920            
 921          
 922          void main (void)
 923          { 
 924   1      //Déclaration des variables
 925   1        //struct COMMANDES_SERIALIZER commande_serializer;
 926   1        struct COMMANDES commande;
 927   1        char message_s[50] = {0};
 928   1        char mess[6] = {0};
 929   1        char echo[3] = {0};
 930   1        char com[50] = {0};
 931   1      //  char nbr[10];
 932   1        char a;
 933   1        char i =0;
 934   1        int b = 0;
 935   1        unsigned char code_err = 0;
 936   1      
 937   1        //a modifier
 938   1        char f_b=6;
 939   1        char t_son=25;
 940   1        char t_silence=50;
 941   1        char bip_b=3;
 942   1      
 943   1        EA=0;
 944   1        Init_Device();  // Initialisation du microcontrôleur
 945   1        Config_Timer2();
 946   1        Config_timer0();
 947   1        Config_SPI_MASTER();
 948   1        CFG_VREF();
 949   1        CFG_ADC0();
 950   1        CFG_Clock_UART();
 951   1        cfg_UART0_mode1();
 952   1        init_Serial_Buffer();   
 953   1        init_Serial_Buffer1();
 954   1        CFG_UART1();
 955   1        NSS_slave = 1;
 956   1        TR2 = 0;
 957   1        EA=1;
 958   1      
 959   1        
 960   1        //Courant_ADC();
 961   1        //fonctionRoutage(commande);
 962   1      
 963   1        serOutstring("\n\rDemarrage robot\n\r>");
 964   1        CDE_Servo_H(90);
 965   1      // a commenter si le robot est déja allumé avant le lancement du code  
 966   1      // Pour recevoir le message de démarrage du serializer
 967   1      /*  do{
 968   1            a=serInchar1();
 969   1            echo[0] = a;
 970   1            echo[1] = '\0';
 971   1            serOutstring(echo);
 972   1            memset(echo,0,strlen(echo));
 973   1          }while(a!=0x3E);
 974   1      */
 975   1        while(1){
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 17  

 976   2      
 977   2          memset(message_s,0,sizeof(message_s));
 978   2          memset(mess, 0, strlen(mess));    
 979   2          memset(message_PC_com, 0, strlen(message_PC_com));    
 980   2      
 981   2          commande_correct =1;
 982   2          
 983   2          i=0;
 984   2          a=0;
 985   2          memset(com, 0, 50);
 986   2      //    do{
 987   2      //      a=serInchar();
 988   2      //      echo[0] = a;
 989   2      //      echo[1] = '\0';
 990   2      //      serOutstring(echo);
 991   2      //      memset(echo,0,strlen(echo));
 992   2      //      if (a!=0x00)
 993   2      //        {
 994   2      //        com[i]=a;
 995   2      //        i=i+1;
 996   2      //        }
 997   2      //      }while(a!=0x0D);
 998   2            
 999   2            
1000   2          //strcpy(com,"SD F:13 P:10 W:50 B:50");
1001   2          strcpy(com,"CS H 45");
1002   2      
1003   2          commande = Message(com/*, f_b, t_son, t_silence, bip_b*/);
*** WARNING C209 IN LINE 1003 OF main.c: '_Message': too few actual parameters
1004   2            /*if(commande.son==emission)
1005   2            {
1006   2              f_b=commande.frequence;
1007   2              t_son=commande.duree_son;
1008   2              t_silence=commande.duree_silence;
1009   2              bip_b=commande.nombre_Bips;
1010   2            }*/
1011   2          if (commande_correct == 1){
1012   3              fonctionRoutage(commande);
1013   3          }
1014   2          if (commande_correct == 2){
1015   3            serOutstring(message_PC_com); // si erreur
1016   3          }
1017   2          if(commande_correct == 0){
1018   3            strcpy(mess, "\n\r#\n\r>");
1019   3            serOutstring(mess); // si erreur
1020   3          }
1021   2        //serOutstring(message_PC_com); // si erreur
1022   2        }
1023   1        
1024   1      }
1025          
1026          void ISR_Timer2 (void) interrupt 5 {
1027   1        TF2 = 0; //Remise à '0' du flag d'overflow
1028   1        PWM_servo=!PWM_servo; //On envoie le signal PWM au servomoteur
1029   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5367    ----
   CONSTANT SIZE    =    383    ----
   XDATA SIZE       =     55     731
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.52.0.0   MAIN                                                              05/15/2018 17:33:28 PAGE 18  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  8 WARNING(S),  0 ERROR(S)
