C51 COMPILER V9.51   ENCODAGE_SON                                                          05/17/2018 18:31:39 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE ENCODAGE_SON
OBJECT MODULE PLACED IN encodage_son.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe encodage_son.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <math.h>
   5          #include <stdlib.h>
   6          
   7          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   8          #include "ultrason.h"
   9          #include "encodage_son.h"
  10          #include "Servomoteur_Horizontal.h"
  11          
  12          struct INFORMATIONS information;
  13          float detection_avant;
  14          float detection_arriere;
  15          char obstacle_avant[5];
  16          char obstacle_arriere[5];
  17          char affichage [256] = 0;
  18          extern char Angle_atteint; // Initaliser à "XX"
  19          char Angle_servo [1] = 0;
  20          
  21          char detection_AV(struct COMMANDES com){
  22   1      
  23   1      
  24   1        detection_avant=MES_Dist_AV();
  25   1        if (detection_avant != 0){ //Si un obstacle est détecté
  26   2          information.Nbre_Val_obst ++; //On incrémente le nbr d'abstacle détecté
  27   2        }
  28   1        if(com.A_Obst != Obst_proche_balayage){
  29   2          //Affichage
  30   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float à char
  31   2          sprintf(Angle_servo,"%c",Angle_atteint); // Convertion de float à char
  32   2          
  33   2          strcat(affichage,Angle_servo); //On donne la position du Servomoteur_Horizontal
  34   2          strcat(affichage," : AV -> ");
  35   2          strcat(affichage,obstacle_avant); //On donne la distance à laquelle est l'obstacle AV
  36   2        }
  37   1        
  38   1        return detection_avant;
  39   1      }
  40          
  41          
  42          char detection_AV_AR(struct COMMANDES com){
  43   1        detection_avant=MES_Dist_AV();
  44   1        detection_arriere=MES_Dist_AR();
  45   1        if (detection_avant != 0){ //Si un obstacle est détecté
  46   2          information.Nbre_Val_obst++; //On incrémente le nbr d'abstacle détecté
  47   2        }
  48   1        if (detection_arriere != 0){ //Si un obstacle est détecté
  49   2          information.Nbre_Val_obst++; //On incrémente le nbr d'abstacle détecté
  50   2        }
  51   1        if(com.A_Obst != Obst_proche_balayage){
  52   2          //Affichage
  53   2      
  54   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float à char
  55   2          sprintf(obstacle_arriere,"%f",detection_arriere); // Convertion de float à char
C51 COMPILER V9.51   ENCODAGE_SON                                                          05/17/2018 18:31:39 PAGE 2   

  56   2          sprintf(Angle_servo,"%c",Angle_atteint); // Convertion de float à char
  57   2          
  58   2          strcat(affichage,Angle_servo); //On donne la position du Servomoteur_Horizontal
  59   2          strcat(affichage," : AV -> ");
  60   2          strcat(affichage,obstacle_avant); //On donne la distance à laquelle est l'obstacle AV
  61   2          strcat(affichage," : AR -> ");
  62   2          strcat(affichage,obstacle_arriere); //On donne la distance à laquelle est l'obstacle AR
  63   2        }
  64   1      
  65   1        return detection_avant,detection_arriere;
  66   1      }
  67          
  68          
  69          struct INFORMATIONS Detect_Obst(struct COMMANDES com){
  70   1        signed int i;
  71   1        int j,k=0;
  72   1        extern float detection_avant,detection_arriere;
  73   1        char tab_dist_AV [50];
  74   1        char tab_dist_AR [50];
  75   1        char tab_angles [50];
  76   1        char dist_min_AV [5];
  77   1        char dist_min_AR [5];
  78   1        char dist_min [5];
  79   1        char angle [5];
  80   1        int min,min_AV,min_AR = 0;
  81   1      
  82   1        switch(com.A_Obst){
  83   2          case Obst_unique:
  84   2            if (com.Det==avant){ //Calcul uniquement pour le télémètre AV
  85   3              detection_AV(com);
  86   3            }
  87   2            else{ //Calcul pour les télémètres AV & AR
  88   3              detection_AV_AR(com);
  89   3            }
  90   2            break;
  91   2            
  92   2          case Obst_balayage:
  93   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180°
  94   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
  95   4                CDE_Servo_H(i); // On met le servomoteur en position
  96   4                detection_AV(com); //On fait une détection AV
  97   4              }
  98   3            }
  99   2            else{ //detection AV et AR sur 360°
 100   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
 101   4                CDE_Servo_H(i); // On met le servomoteur en position
 102   4                detection_AV_AR(com); //On fait une détection AV et AR
 103   4              }
 104   3            }
 105   2            break;
 106   2      
 107   2          case Obst_proche_balayage:
 108   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180°
 109   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
 110   4                tab_angles[k] = CDE_Servo_H(i); // On met le servomoteur en position
 111   4                tab_dist_AV[k] = detection_AV(com); //On fait une détection AV
 112   4                k++;
 113   4              }
 114   3              for (j=0; j<sizeof(tab_dist_AV); j++){//Recherche de la distance minimale parmis toutes celle trouvée
 115   4                if(tab_dist_AV[j] < tab_dist_AV[min]){
 116   5                  min = j;
 117   5                }
C51 COMPILER V9.51   ENCODAGE_SON                                                          05/17/2018 18:31:39 PAGE 3   

 118   4              }
 119   3              dist_min[0] = tab_dist_AV[min];
 120   3              angle[0] = tab_angles[min];
 121   3              
 122   3              //Affichage
 123   3              strcat(affichage,angle); //On donne la position du Servomoteur_Horizontal
 124   3              strcat(affichage," : AV -> ");
 125   3              strcat(affichage,dist_min); //On donne la distance à laquelle est l'obstacle AV
 126   3            }
 127   2            else{ //detection AV et AR sur 360°
 128   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
 129   4                tab_angles[k] = CDE_Servo_H(i); // On met le servomoteur en position
 130   4                tab_dist_AV[k],tab_dist_AR[k] = detection_AV_AR(com); //On fait une détection AV et AR
 131   4                k++;
 132   4              }
 133   3              for (j=0; j<sizeof(tab_dist_AV); j++){//Recherche de la distance minimale AV parmis toutes celle trouv
             -ée
 134   4                if(tab_dist_AV[j] < tab_dist_AV[min_AV]){
 135   5                  min_AV = j;
 136   5                }
 137   4              }
 138   3              dist_min_AV[0] = tab_dist_AV[min_AV];
 139   3              for (j=0; j<sizeof(tab_dist_AR); j++){//Recherche de la distance minimale AR parmis toutes celle trouv
             -ée
 140   4                if(tab_dist_AR[j] < tab_dist_AR[min_AR]){
 141   5                  min_AR = j;
 142   5                }
 143   4              }
 144   3              dist_min_AR[0] = tab_dist_AR[min];
 145   3              if (dist_min_AR < dist_min_AV){
 146   4                dist_min[0] = dist_min_AR;
 147   4                angle[0] = tab_angles[min_AR];
 148   4              }
 149   3              else{
 150   4                dist_min[0] = dist_min_AV;
 151   4                angle[0] = tab_angles[min_AV];
 152   4              }
 153   3              
 154   3              //Affichage
 155   3              strcat(affichage,angle); //On donne la position du Servomoteur_Horizontal
 156   3              strcat(affichage," : AR -> ");
 157   3              strcat(affichage,dist_min); //On donne la distance à laquelle est l'obstacle AR
 158   3            }
 159   2            break;
 160   2        }
 161   1        
 162   1        return information;
 163   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1513    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =    301     293
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
