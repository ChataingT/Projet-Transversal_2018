C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE FONCTIONS_COTE_SERIALIZER
OBJECT MODULE PLACED IN Fonctions_cote_serializer.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Fonctions_cote_serializer.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <c8051f020.h>
   2          
   3          #include "Fonctions_cote_serializer.h"
   4          
   5          //#include "FO_M2_Structures_COMMANDES_INFORMATIONS_Serializer.h"
   6          
   7          /** 
   8          convertion ordre reçu par le centrale de controle en ordre pour 
   9          le robot
  10          Fonction decodage action
  11          
  12          Fonction mouvement elementaire :
  13          avancer (distance)
  14          avancer (temps, vitesse)
  15          
  16          reculer (distance)
  17          reculer (temps, vitesse)
  18          
  19          tourner (degrée)
  20          **/
  21          
  22          /**
  23          All commands and parameters are separated by spaces. 
  24          There are two types of parameters: Simple and Complex. 
  25          Simple parameters are basically simple strings, 
  26          such as “hello” or “1”. 
  27          Complex parameters are simple strings separated by colons “:”, 
  28          such as “hello:world” or “2:1”.message fini par /r
  29          
  30          All commands (and associated parameters) are terminated by an ASCII 
  31          carriage-return character “\r” (0x0D).
  32          
  33          reponse du serializer : 
  34          Ret/r/n< -> réussite + ret = réponse de retour
  35          ACK/r/n< -> réussite sans réponse de retour
  36          NACK/r/n< -> échec
  37          
  38          **/
  39          
  40          int conv_distance_ticks(int d){ // convertion d[m] en ticks  
  41   1        int ret = ceil(d/(0.3*0.001)); //624ticks = 1tour et diamêtre roue = 60mm
  42   1        return ret;
  43   1      }
  44          
  45          int conv_angle_ticks(int angle){ 
  46   1        int ret;
  47   1        float a = angle/360.0;
  48   1        ret = ceil(4600*a); //2346ticks = 1 360° du robot
  49   1        return ret;
  50   1      }
  51          
  52          void itos(int i, char * ret){
  53   1        char nbr3[3];
  54   1        char nbr2[2];
  55   1        char nbr1[1];
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 2   

  56   1        int c = i/100;
  57   1        int d = (i-c*100)/10;
  58   1        int u = i-c*100-d*10;
  59   1        
  60   1        if (i > 99) {
  61   2          nbr3[0] = c+'0';
  62   2          nbr3[1] = d+'0';
  63   2          nbr3[2] = u+'0';
  64   2          strcpy(ret,nbr3);
  65   2        }
  66   1        else if (i > 9) {
  67   2          nbr2[0] = d+'0';
  68   2          nbr2[1] = u+'0';
  69   2          strcpy(ret,nbr2);
  70   2        }
  71   1        else {
  72   2          nbr1[0] = u+'0';
  73   2          strcpy(ret,nbr1);
  74   2        }
  75   1      }
  76          
  77          int true_vit(unsigned char vit){
  78   1        int ret = vit;
  79   1        
  80   1        if ( vit >= 100){
  81   2          ret = -(vit - 100);
  82   2        }
  83   1        return ret;
  84   1      }
  85          
  86          void true_ticks(int ticks, char * ret){
  87   1        char str[4] = {0};
  88   1        int l = 0;
  89   1      
  90   1        if ( ticks >= 0){ //  différentitation angle positife et négatif
  91   2          sprintf(ret, "%d", ticks);
  92   2        }
  93   1        else{
  94   2          ticks = -1*ticks;
  95   2          strcpy(ret,"-");
  96   2          sprintf(str, "%d", ticks);
  97   2          strcat(ret,str);
  98   2          l = strlen(str)+2;
  99   2          ret[l]='\0'; // on force la fin de chaine
 100   2        }
 101   1      }
 102          /* entré : une structure représenatnt une commande destiné au serializer
 103            sortie : une chaine de caractère qui est la commande à envoyer au serializer
 104          
 105          fonctionnement : à l'aide de l'enum Etat_commande qui représente l'action à éffectué par le serializer
 106           on effectue un switch qui construit une chaine de caractère avec les paramêtre necessaire
 107          */
 108          
 109          /*
 110          A faire : astuce pour les ticks négatif : test avant le sprintf si 
 111          le int > 63... et si oui copie  d'un moins avant sinon copie normale
 112          */
 113          void formate_serializer(struct COMMANDES_SERIALIZER com, char * ret){
 114   1        char nbr[9];
 115   1        
 116   1        switch (com.Etat_Commande){
 117   2          case Reset :{
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 3   

 118   3            strcpy(ret,"reset");
 119   3            break;
 120   3          }
 121   2          case Getenc_1 :{
 122   3            break;
 123   3          }
 124   2          case Getenc_2 :{
 125   3            break;
 126   3          }
 127   2          case Getenc_1_2 :{
 128   3            break;
 129   3          }
 130   2          case Clrenc_1 :{
 131   3              break;
 132   3          }
 133   2          case Clrenc_2 :{
 134   3            break;
 135   3          }
 136   2          case Clrenc_1_2 :{
 137   3            break;
 138   3          }
 139   2          case mogo_1 :{
 140   3            strcpy(ret,"mogo 1:");
 141   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot1));
 142   3            strcat(ret,nbr);
 143   3            break;
 144   3          }
 145   2          case mogo_2 :{
 146   3            strcpy(ret,"mogo 2:");
 147   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot2));
 148   3            strcat(ret,nbr);
 149   3            break;
 150   3          }
 151   2          case mogo_1_2 :{
 152   3            strcpy(ret,"mogo 1:");
 153   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot1));
 154   3            strcat(ret,nbr);
 155   3            strcat(ret," 2:");
 156   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot2));
 157   3            strcat(ret,nbr);
 158   3            break;
 159   3          }
 160   2          case Vpid_set :{
 161   3            strcpy(ret,"vpid ");
 162   3            sprintf(nbr, "%d", com.Set_P);
 163   3            strcat(ret,nbr);
 164   3            strcat(ret,":");
 165   3            sprintf(nbr, "%d", com.Set_I);
 166   3            strcat(ret,nbr);
 167   3            strcat(ret,":");
 168   3            sprintf(nbr, "%d", com.Set_D);
 169   3            strcat(ret,nbr);
 170   3            strcat(ret,":");
 171   3            sprintf(nbr, "%d", com.Set_L_A);
 172   3            strcat(ret,nbr);
 173   3            strcat(ret,":");
 174   3            break;
 175   3          }
 176   2          case Vpid_read :{
 177   3            strcpy(ret,"vpid");
 178   3            break;
 179   3          }
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 4   

 180   2          case digo_1 :{
 181   3            strcpy(ret,"digo 1:");
 182   3            true_ticks(com.Ticks_mot1, nbr);
 183   3            strcat(ret,nbr);
 184   3            strcat(ret,":");
 185   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot1));
 186   3            strcat(ret,nbr);
 187   3            break;
 188   3          }
 189   2          case digo_2 :{
 190   3            strcpy(ret,"digo 2:");
 191   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot2));
 192   3            strcat(ret,nbr);
 193   3            strcat(ret,":");
 194   3            true_ticks(com.Ticks_mot2, nbr);
 195   3            strcat(ret,nbr);
 196   3            break;
 197   3          }
 198   2          case digo_1_2 :{
 199   3            strcpy(ret,"digo 1:");
 200   3            true_ticks(com.Ticks_mot1, nbr);
 201   3            strcat(ret,nbr);
 202   3            strcat(ret,":");
 203   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot1));
 204   3            strcat(ret,nbr);
 205   3            strcat(ret," 2:");
 206   3            true_ticks(com.Ticks_mot2, nbr);
 207   3            strcat(ret,nbr);
 208   3            strcat(ret,":");
 209   3            sprintf(nbr, "%d", true_vit(com.Vitesse_Mot2));
 210   3            strcat(ret,nbr);
 211   3            break;
 212   3          }
 213   2          case Dpid_set :{
 214   3            strcpy(ret,"dpid ");
 215   3            sprintf(nbr, "%d",com.Set_P);
 216   3            strcat(ret,nbr);
 217   3            strcat(ret,":");
 218   3            sprintf(nbr, "%d", com.Set_I);
 219   3            strcat(ret,nbr);
 220   3            strcat(ret,":");
 221   3            sprintf(nbr, "%d", com.Set_D);
 222   3            strcat(ret,nbr);
 223   3            strcat(ret,":");
 224   3            sprintf(nbr, "%d", com.Set_L_A);
 225   3            strcat(ret,nbr);
 226   3            strcat(ret,":");
 227   3            break;
 228   3          }
 229   2          case Dpid_read :{
 230   3            strcpy(ret,"vpid");
 231   3            break;
 232   3          }
 233   2          case Rpid_Stinger :{
 234   3            break;
 235   3          }
 236   2          case Pids :{
 237   3            break;
 238   3          }
 239   2          case Stop :{
 240   3            strcpy(ret,"stop");
 241   3            break;
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 5   

 242   3          }
 243   2          case Vel :{
 244   3            strcpy(ret,"vel");
 245   3            break;
 246   3          }
 247   2          case Restore :{
 248   3            strcpy(ret,"restore");
 249   3            break;
 250   3          }
 251   2          default:
 252   2            break;
 253   2        }
 254   1        strcat(ret,"\r");
 255   1      }
 256          /* entré : une structure représentant une commande envoyé par le PC de commande
 257            sortie : une structure représentant une commande destiné 
 258          
 259          fonctionnement : à l'aide de l'enum Etat_Epreuve et Etat_Mouvement
 260          on remplit une strucutre COMMANDES_SERIALIZER avec les paramètre destiné au serializer
 261          */
 262          struct COMMANDES_SERIALIZER transcode_commande_to_serializer (struct COMMANDES com) {
 263   1        struct  COMMANDES_SERIALIZER ret;
 264   1        char v_angl = 20;
 265   1        char v_line = 30;
 266   1      
 267   1        switch (com.Etat_Epreuve){//"D" "E" "Q"
 268   2          case Stop_Urgence:{
 269   3            ret.Etat_Commande = Stop;
 270   3            break;
 271   3          }
 272   2          default:
 273   2            break;
 274   2        }
 275   1          
 276   1        switch (com.Etat_Mouvement){
 277   2          // avancer  
 278   2          case Avancer:{ 
 279   3            ret.Etat_Commande = mogo_1_2;
 280   3            if (com.Vitesse == '0'){
 281   4              com.Vitesse = v_line;
 282   4            }
 283   3            ret.Vitesse_Mot1 = com.Vitesse;
 284   3            ret.Vitesse_Mot2 = com.Vitesse;
 285   3            break;
 286   3          }
 287   2          // reculer
 288   2          case(Reculer):{ 
 289   3              ret.Etat_Commande = mogo_1_2;
 290   3              if (com.Vitesse == '0'){
 291   4                com.Vitesse = v_line;
 292   4              }
 293   3              ret.Vitesse_Mot1 = com.Vitesse + 100;
 294   3              ret.Vitesse_Mot2 = com.Vitesse + 100;
 295   3              break;
 296   3          }
 297   2          // stop   
 298   2          case(Stopper):{ 
 299   3              ret.Etat_Commande = Stop;
 300   3              break;
 301   3          }
 302   2          // rotation 90° droite 
 303   2          case(Rot_90D):{ // motor1 = droite motor2 = gauche
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 6   

 304   3              if (com.Vitesse == '0'){
 305   4                com.Vitesse = v_angl;
 306   4              }
 307   3              ret.Etat_Commande = digo_1_2;
 308   3              ret.Vitesse_Mot1 = com.Vitesse;
 309   3              ret.Ticks_mot1 = -conv_angle_ticks(45);
 310   3              ret.Vitesse_Mot2 = (com.Vitesse);
 311   3              ret.Ticks_mot2 = conv_angle_ticks(45);
 312   3              break;
 313   3          }
 314   2          // rotation 90° gauche
 315   2          case(Rot_90G):{ 
 316   3              if (com.Vitesse == '0'){
 317   4                com.Vitesse = v_angl;
 318   4              }
 319   3              ret.Etat_Commande = digo_1_2;
 320   3              ret.Vitesse_Mot1 = (com.Vitesse);
 321   3              ret.Ticks_mot1 = conv_angle_ticks(45);
 322   3              ret.Vitesse_Mot2 = com.Vitesse;
 323   3              ret.Ticks_mot2 = -conv_angle_ticks(45);
 324   3              break;
 325   3          }
 326   2          // rotation 180° droite
 327   2          case(Rot_180D):{ 
 328   3              if (com.Vitesse == '0'){
 329   4                com.Vitesse = v_angl;
 330   4              }
 331   3              ret.Etat_Commande = digo_1_2;
 332   3              ret.Vitesse_Mot1 = com.Vitesse;
 333   3              ret.Ticks_mot1 = -conv_angle_ticks(90);
 334   3              ret.Vitesse_Mot2 = (com.Vitesse);
 335   3              ret.Ticks_mot2 = conv_angle_ticks(90);
 336   3              break;
 337   3          }
 338   2          // rotation 180° gauche
 339   2          case(Rot_180G):{ 
 340   3              if (com.Vitesse == '0'){
 341   4                com.Vitesse = v_angl;
 342   4              }
 343   3              ret.Etat_Commande = digo_1_2;
 344   3              ret.Vitesse_Mot1 = (com.Vitesse);
 345   3              ret.Ticks_mot1 = conv_angle_ticks(90);
 346   3              ret.Vitesse_Mot2 = com.Vitesse;
 347   3              ret.Ticks_mot2 = -conv_angle_ticks(90);
 348   3              break;
 349   3          }
 350   2              
 351   2          // rotation d'un angle donné à droite
 352   2          case(Rot_AngD):{ 
 353   3              if (com.Vitesse == '0'){
 354   4                com.Vitesse = v_angl;
 355   4              }
 356   3              ret.Etat_Commande = digo_1_2;
 357   3              ret.Vitesse_Mot1 = com.Vitesse;
 358   3              ret.Ticks_mot1 = -conv_angle_ticks(com.Angle/2);
 359   3              ret.Vitesse_Mot2 = (com.Vitesse);
 360   3              ret.Ticks_mot2 = conv_angle_ticks(com.Angle/2);
 361   3              break;
 362   3          }
 363   2          // rotation d'un angle donné à droite   
 364   2          case(Rot_AngG):{ 
 365   3              if (com.Vitesse == '0'){
C51 COMPILER V9.51   FONCTIONS_COTE_SERIALIZER                                             05/08/2018 11:45:54 PAGE 7   

 366   4                com.Vitesse = v_angl;
 367   4              }
 368   3              ret.Etat_Commande = digo_1_2;
 369   3              ret.Vitesse_Mot1 = (com.Vitesse);
 370   3              ret.Ticks_mot1 = conv_angle_ticks(com.Angle/2);
 371   3              ret.Vitesse_Mot2 = com.Vitesse;
 372   3              ret.Ticks_mot2 = -conv_angle_ticks(com.Angle/2);
 373   3              break;
 374   3          }
 375   2              
 376   2          case(Depl_Coord):{
 377   3              if (com.Vitesse == '0'){
 378   4                com.Vitesse = v_angl;
 379   4              }
 380   3              if (com.Angle >= 0 ){
 381   4                ret.Etat_Commande = digo_1_2;
 382   4                ret.Vitesse_Mot1 = (com.Vitesse);
 383   4                ret.Ticks_mot1 = conv_angle_ticks(com.Angle/2);
 384   4                ret.Vitesse_Mot2 = com.Vitesse + 100;
 385   4                ret.Ticks_mot2 = -conv_angle_ticks(com.Angle/2);
 386   4              }
 387   3              else {
 388   4                com.Angle = -com.Angle;
 389   4                ret.Etat_Commande = digo_1_2;
 390   4                ret.Vitesse_Mot1 = com.Vitesse + 100;
 391   4                ret.Ticks_mot1 = -conv_angle_ticks(com.Angle/2);
 392   4                ret.Vitesse_Mot2 = (com.Vitesse);
 393   4                ret.Ticks_mot2 = conv_angle_ticks(com.Angle/2);
 394   4              }
 395   3              break;
 396   3          }
 397   2          default:
 398   2              break;
 399   2        }
 400   1      
 401   1        return ret;
 402   1      }
 403            
 404            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2732    ----
   CONSTANT SIZE    =     89    ----
   XDATA SIZE       =   ----     108
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
