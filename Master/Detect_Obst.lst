C51 COMPILER V9.51   DETECT_OBST                                                           05/22/2018 23:14:47 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE DETECT_OBST
OBJECT MODULE PLACED IN Detect_Obst.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Src\Detect_Obst.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Detect_Obst.lst) 
                    -TABS(2) OBJECT(Detect_Obst.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <math.h>
   5          #include <stdlib.h>
   6          
   7          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   8          #include "ultrason.h"
   9          #include "Detect_Obst.h"
  10          #include "Servomoteur_Horizontal.h"
  11          
  12          struct INFORMATIONS information;
  13          float detection_avant;
  14          float detection_arriere;
  15          char obstacle_avant[5];
  16          char obstacle_arriere[5];
  17          char affichage [256] = 0;
  18          extern signed int Angle_atteint; // Initaliser � "XX"
  19          char Angle_servo [3] = {0};
  20          
  21          char detection_AV(struct COMMANDES com){
  22   1      
  23   1      
  24   1        detection_avant=MES_Dist_AV();
  25   1        if (detection_avant != 0){ //Si un obstacle est d�tect�
  26   2          information.Nbre_Val_obst ++; //On incr�mente le nbr d'abstacle d�tect�
  27   2        }
  28   1        if(com.A_Obst != Obst_proche_balayage){
  29   2          //Affichage
  30   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float � char
  31   2          sprintf(Angle_servo,"%i",Angle_atteint); // Convertion de float � char
  32   2          strcat(affichage," //// ");
  33   2          strcat(affichage,Angle_servo); //On donne la position du Servomoteur_Horizontal
  34   2          strcat(affichage," : ");
  35   2          strcat(affichage,obstacle_avant); //On donne la distance � laquelle est l'obstacle AV
  36   2        }
  37   1      
  38   1        return detection_avant;
  39   1      }
  40          
  41          
  42          char detection_AV_AR(struct COMMANDES com){
  43   1        detection_avant=MES_Dist_AV();
  44   1        detection_arriere=MES_Dist_AR();
  45   1        if (detection_avant != 0){ //Si un obstacle est d�tect�
  46   2          information.Nbre_Val_obst++; //On incr�mente le nbr d'abstacle d�tect�
  47   2        }
  48   1        if (detection_arriere != 0){ //Si un obstacle est d�tect�
  49   2          information.Nbre_Val_obst++; //On incr�mente le nbr d'abstacle d�tect�
  50   2        }
  51   1        if(com.A_Obst != Obst_proche_balayage){
  52   2          //Affichage
  53   2      
  54   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float � char
C51 COMPILER V9.51   DETECT_OBST                                                           05/22/2018 23:14:47 PAGE 2   

  55   2          sprintf(obstacle_arriere,"%f",detection_arriere); // Convertion de float � char
  56   2          sprintf(Angle_servo,"%i",Angle_atteint); // Convertion de float � char
  57   2      
  58   2          strcat(affichage,Angle_servo); //On donne la position du Servomoteur_Horizontal
  59   2          strcat(affichage," : ");
  60   2          strcat(affichage,obstacle_avant); //On donne la distance � laquelle est l'obstacle AV
  61   2          strcat(affichage," : ");
  62   2          strcat(affichage,obstacle_arriere); //On donne la distance � laquelle est l'obstacle AR
  63   2          strcat(affichage," //// ");
  64   2      
  65   2        }
  66   1      
  67   1        return detection_avant,detection_arriere;
  68   1      }
  69          
  70          
  71          struct INFORMATIONS Detect_Obst(struct COMMANDES com){
  72   1        signed int i;
  73   1        int j;
  74   1        int k=0;
  75   1        extern float detection_avant,detection_arriere;
  76   1        float tab_dist_AV [50];
  77   1        float tab_dist_AR [50];
  78   1        signed int tab_angles [50];
  79   1        float dist_min_AV [5];
  80   1        float dist_min_AR [5];
  81   1        float dist_min;
  82   1        char dist_min_ascii [5];
  83   1        signed int angle;
  84   1        signed char angle_ascii [5];
  85   1        int min = 0;
  86   1        int min_AV = 0;
  87   1        int min_AR = 0;
  88   1        int z;
  89   1      
  90   1        switch(com.A_Obst){
  91   2          case Obst_unique:
  92   2            if (com.Det==avant){ //Calcul uniquement pour le t�l�m�tre AV
  93   3              detection_AV(com);
  94   3            }
  95   2            else{ //Calcul pour les t�l�m�tres AV & AR
  96   3              detection_AV_AR(com);
  97   3            }
  98   2            break;
  99   2      
 100   2          case Obst_balayage:
 101   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180�
 102   3              for(i = 0xFFA6 ;i<=0x5A;i = i+com.DCT_Obst_Resolution){
 103   4                Angle_atteint = CDE_Servo_H(i); // On met le servomoteur en position
 104   4                for (z = 0;z<30000;z++);
 105   4                detection_AV(com); //On fait une d�tection AV
 106   4              }
 107   3            }
 108   2            else{ //detection AV et AR sur 360�
 109   3              for(i = 0xFFA6;i<=0x5A;i = i+com.DCT_Obst_Resolution){
 110   4                Angle_atteint = CDE_Servo_H(i); // On met le servomoteur en position
 111   4                for (z = 0;z<30000;z++);
 112   4                detection_AV_AR(com); //On fait une d�tection AV et AR
 113   4              }
 114   3            }
 115   2            break;
 116   2      
C51 COMPILER V9.51   DETECT_OBST                                                           05/22/2018 23:14:47 PAGE 3   

 117   2            
 118   2            
 119   2            
 120   2            
 121   2            
 122   2            
 123   2            
 124   2            
 125   2            
 126   2            
 127   2            
 128   2            
 129   2            
 130   2            
 131   2            
 132   2            
 133   2            
 134   2            
 135   2            
 136   2            
 137   2            
 138   2            
 139   2            
 140   2            
 141   2          case Obst_proche_balayage:
 142   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180�
 143   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
 144   4                tab_angles[k] = CDE_Servo_H(i); // On met le servomoteur en position
 145   4                tab_dist_AV[k] = detection_AV(com); //On fait une d�tection AV
 146   4                k++;
 147   4              }
 148   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale parmis toutes ce
             -lle trouv�e
 149   4                if(tab_dist_AV[j] < tab_dist_AV[min]){
 150   5                  min = j;
 151   5                }
 152   4              }
 153   3              dist_min = tab_dist_AV[min];
 154   3              angle = tab_angles[min];
 155   3      
 156   3              //Affichage
 157   3              sprintf(dist_min_ascii,"%f",dist_min); // Convertion de float � char
 158   3              sprintf(angle_ascii,"%d",angle); // Convertion de int � char
 159   3      
 160   3              strcat(affichage,angle_ascii); //On donne la position du Servomoteur_Horizontal
 161   3              strcat(affichage," : AV -> ");
 162   3              strcat(affichage,dist_min_ascii); //On donne la distance � laquelle est l'obstacle AV
 163   3            }
 164   2            else{ //detection AV et AR sur 360�
 165   3              for(i = -90;i<=90;i = i+com.DCT_Obst_Resolution){
 166   4                tab_angles[k] = CDE_Servo_H(i); // On met le servomoteur en position
 167   4                tab_dist_AV[k],tab_dist_AR[k] = detection_AV_AR(com); //On fait une d�tection AV et AR
 168   4                k++;
 169   4              }
 170   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale AV parmis toutes
             - celle trouv�e
 171   4                if(tab_dist_AV[j] < tab_dist_AV[min_AV]){
 172   5                  min_AV = j;
 173   5                }
 174   4              }
 175   3              dist_min_AV[0] = tab_dist_AV[min_AV];
 176   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale AR parmis toutes
C51 COMPILER V9.51   DETECT_OBST                                                           05/22/2018 23:14:47 PAGE 4   

             - celle trouv�e
 177   4                if(tab_dist_AR[j] < tab_dist_AR[min_AR]){
 178   5                  min_AR = j;
 179   5                }
 180   4              }
 181   3              dist_min_AR[0] = tab_dist_AR[min];
 182   3              if (dist_min_AR < dist_min_AV){
 183   4                dist_min = dist_min_AR[min_AR];
 184   4                angle = tab_angles[min_AR];
 185   4              }
 186   3              else{
 187   4                dist_min = dist_min_AV[min_AV];
 188   4                angle = tab_angles[min_AV];
 189   4              }
 190   3      
 191   3              //Affichage
 192   3              sprintf(dist_min_ascii,"%f",dist_min); // Convertion de float � char
 193   3              sprintf(angle_ascii,"%d",angle); // Convertion de int � char
 194   3      
 195   3              strcat(affichage,angle_ascii); //On donne la position du Servomoteur_Horizontal
 196   3              strcat(affichage," : ");
 197   3              strcat(affichage,dist_min_ascii); //On donne la distance � laquelle est l'obstacle AV
 198   3            }
 199   2            break;
 200   2        }
 201   1      
 202   1        return information;
 203   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2297    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =    303     684
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
