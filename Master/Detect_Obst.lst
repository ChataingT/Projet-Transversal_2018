C51 COMPILER V9.51   DETECT_OBST                                                           05/23/2018 10:43:45 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE DETECT_OBST
OBJECT MODULE PLACED IN Detect_Obst.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Src\Detect_Obst.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Detect_Obst.lst) 
                    -TABS(2) OBJECT(Detect_Obst.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <math.h>
   5          #include <stdlib.h>
   6          
   7          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   8          #include "ultrason.h"
   9          #include "Detect_Obst.h"
  10          #include "Servomoteur_Horizontal.h"
  11          
  12          struct INFORMATIONS information;
  13          float detection_avant;
  14          float detection_arriere;
  15          char obstacle_avant[5];
  16          char obstacle_arriere[5];
  17          char affichage [256] = 0;
  18          extern signed int Angle_atteint; // Initaliser � "XX"
  19          char Angle_servo [3] = {0};
  20          
  21          signed int c;
  22          int j;
  23          int k=0;
  24          extern float detection_avant,detection_arriere;
  25          float tab_dist_AV [50];
  26          float tab_dist_AR [50];
  27          signed int tab_angles [50];
  28          float dist_min_AV [5];
  29          float dist_min_AR [5];
  30          float dist_min;
  31          char dist_min_ascii [5];
  32          signed int angle_min;
  33          signed char angle_ascii [5];
  34          int min = 0;
  35          int min_AV = 0;
  36          int min_AR = 0;
  37          int z;
  38          
  39          void Affichage_AV(char obst_AV [5],char Serv [5]){
  40   1      
  41   1          strcat(affichage,Serv); //On donne la position du Servomoteur_Horizontal
  42   1          strcat(affichage," : ");
  43   1          strcat(affichage,obst_AV); //On donne la distance � laquelle est l'obstacle AV
  44   1          strcat(affichage,"\n\r>");
  45   1      
  46   1      }
  47          
  48          void Affichage_AV_AR(char obst_AV [5],char obst_AR [5],char Serv [5]){
  49   1          
  50   1          strcat(affichage,Serv); //On donne la position du Servomoteur_Horizontal
  51   1          strcat(affichage," : ");
  52   1          strcat(affichage,obst_AV); //On donne la distance � laquelle est l'obstacle AV
  53   1          strcat(affichage," : ");
  54   1          strcat(affichage,obst_AR); //On donne la distance � laquelle est l'obstacle AR
C51 COMPILER V9.51   DETECT_OBST                                                           05/23/2018 10:43:45 PAGE 2   

  55   1          strcat(affichage,"\n\r>");
  56   1      
  57   1      }
  58          
  59          
  60          
  61          
  62          
  63          
  64          char detection_AV(struct COMMANDES com){
  65   1      
  66   1        detection_avant=MES_Dist_AV();
  67   1        if (detection_avant != 0){ //Si un obstacle est d�tect�
  68   2          information.Nbre_Val_obst ++; //On incr�mente le nbr d'abstacle d�tect�
  69   2        }
  70   1        if(com.A_Obst != Obst_proche_balayage){
  71   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float � char
  72   2          sprintf(Angle_servo,"%i",Angle_atteint); // Convertion de float � char
  73   2          
  74   2          Affichage_AV(obstacle_avant,Angle_servo); //On affiche
  75   2        }
  76   1        return detection_avant;
  77   1      }
  78          
  79          
  80          char detection_AV_AR(struct COMMANDES com){
  81   1        detection_avant=MES_Dist_AV();
  82   1        detection_arriere=MES_Dist_AR();
  83   1        if (detection_avant != 0){ //Si un obstacle est d�tect�
  84   2          information.Nbre_Val_obst++; //On incr�mente le nbr d'abstacle d�tect�
  85   2        }
  86   1        if (detection_arriere != 0){ //Si un obstacle est d�tect�
  87   2          information.Nbre_Val_obst++; //On incr�mente le nbr d'abstacle d�tect�
  88   2        }
  89   1        if(com.A_Obst != Obst_proche_balayage){
  90   2          sprintf(obstacle_avant,"%f",detection_avant); // Convertion de float � char
  91   2          sprintf(obstacle_arriere,"%f",detection_arriere); // Convertion de float � char
  92   2          sprintf(Angle_servo,"%i",Angle_atteint); // Convertion de float � char
  93   2          
  94   2          Affichage_AV_AR(obstacle_avant,obstacle_arriere,Angle_servo); //On affiche
  95   2        }
  96   1      
  97   1        return detection_avant,detection_arriere;
  98   1      }
  99          
 100          
 101          
 102          struct INFORMATIONS Detect_Obst(struct COMMANDES com){
 103   1      
 104   1      
 105   1        switch(com.A_Obst){
 106   2          case Obst_unique:
 107   2            if (com.Det==avant){ //Calcul uniquement pour le t�l�m�tre AV
 108   3              detection_AV(com);
 109   3            }
 110   2            else{ //Calcul pour les t�l�m�tres AV & AR
 111   3              detection_AV_AR(com);
 112   3            }
 113   2            break;
 114   2      
 115   2          case Obst_balayage:
 116   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180�
C51 COMPILER V9.51   DETECT_OBST                                                           05/23/2018 10:43:45 PAGE 3   

 117   3              for(c = 0xFFA6 ;c<=0x5A;c = c+com.DCT_Obst_Resolution){
 118   4                Angle_atteint = CDE_Servo_H(c); // On met le servomoteur en position
 119   4                for (z = 0;z<30000;z++);//Tempo
 120   4                detection_AV(com); //On fait une d�tection AV
 121   4              }
 122   3            }
 123   2            else{ //detection AV et AR sur 360�
 124   3              for(c = 0xFFA6;c<=0x5A;c = c+com.DCT_Obst_Resolution){
 125   4                Angle_atteint = CDE_Servo_H(c); // On met le servomoteur en position
 126   4                for (z = 0;z<30000;z++);//Tempo
 127   4                detection_AV_AR(com); //On fait une d�tection AV et AR
 128   4              }
 129   3            }
 130   2            break;
 131   2      
 132   2            
 133   2        
 134   2            
 135   2          case Obst_proche_balayage:
 136   2            if (com.Etat_DCT_Obst==oui_180){ //detection AV sur 180�
 137   3              for(c = 0xFFA6;c<=0x5A;c = c+com.DCT_Obst_Resolution){
 138   4                tab_angles[k] = CDE_Servo_H(c); // On met le servomoteur en position
 139   4                for (z = 0;z<30000;z++);//Tempo
 140   4                tab_dist_AV[k] = detection_AV(com); //On fait une d�tection AV
 141   4                k++;
 142   4              }
 143   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale parmis toutes ce
             -lle trouv�e
 144   4                if(tab_dist_AV[j] < tab_dist_AV[min]){
 145   5                  min = j;
 146   5                }
 147   4              }
 148   3              dist_min = tab_dist_AV[min];
 149   3              angle_min = tab_angles[min];
 150   3      
 151   3      
 152   3              //Affichage
 153   3              sprintf(dist_min_ascii,"%f",dist_min); // Convertion de float � char
 154   3              sprintf(angle_ascii,"%d",angle_min); // Convertion de int � char
 155   3              
 156   3              Affichage_AV(dist_min_ascii,angle_ascii); //On affiche
 157   3      
 158   3            }
 159   2            else{ //detection AV et AR sur 360�
 160   3              for(c = 0xFFA6;c<=0x5A;c = c+com.DCT_Obst_Resolution){
 161   4                tab_angles[k] = CDE_Servo_H(c); // On met le servomoteur en position
 162   4                for (z = 0;z<30000;z++);//Tempo
 163   4                tab_dist_AV[k],tab_dist_AR[k] = detection_AV_AR(com); //On fait une d�tection AV et AR
 164   4                k++;
 165   4              }
 166   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale AV parmis toutes
             - celle trouv�e
 167   4                if(tab_dist_AV[j] < tab_dist_AV[min_AV]){
 168   5                  min_AV = j;
 169   5                }
 170   4              }
 171   3              dist_min_AV[0] = tab_dist_AV[min_AV];
 172   3              for (j=0; j<= (180/com.DCT_Obst_Resolution); j++){//Recherche de la distance minimale AR parmis toutes
             - celle trouv�e
 173   4                if(tab_dist_AR[j] < tab_dist_AR[min_AR]){
 174   5                  min_AR = j;
 175   5                }
C51 COMPILER V9.51   DETECT_OBST                                                           05/23/2018 10:43:45 PAGE 4   

 176   4              }
 177   3              dist_min_AR[0] = tab_dist_AR[min];
 178   3              //On regarde quelle est la distance minimale entre l'AV et l'AR
 179   3              if (dist_min_AR < dist_min_AV){
 180   4                dist_min = dist_min_AR[min_AR];
 181   4                angle_min = tab_angles[min_AR];
 182   4              }
 183   3              else{
 184   4                dist_min = dist_min_AV[min_AV];
 185   4                angle_min = tab_angles[min_AV];
 186   4              }
 187   3      
 188   3              sprintf(dist_min_ascii,"%f",dist_min); // Convertion de float � char
 189   3              sprintf(angle_ascii,"%d",angle_min); // Convertion de int � char
 190   3              
 191   3              Affichage_AV(dist_min_ascii,angle_ascii); //On affiche
 192   3            }
 193   2            break;
 194   2        }
 195   1      
 196   1        return information;
 197   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2289    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =    873     129
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
