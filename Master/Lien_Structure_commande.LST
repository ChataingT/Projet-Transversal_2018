C51 COMPILER V9.52.0.0   LIEN_STRUCTURE_COMMANDE                                           05/16/2018 12:04:52 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LIEN_STRUCTURE_COMMANDE
OBJECT MODULE PLACED IN Lien_Structure_commande.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Lien_Structure_commande.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h> 
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   7          #include "ADC.h"
   8          #include "Servomoteur_horizontal.h"
   9          #include "ultrason.h"
  10          #include "Fonctions_cote_serializer.h"
  11          #include "Declarations_GPIO.h"
  12          #include "Config_Globale.h"
  13          #include "Timers.h"
  14          #include "Config_SPI.h"
  15          #include "Transmission_SPI.h"
  16          #include "UART0_RingBuffer_lib.h"
  17          #include "ConfigUART1.h"
  18          #include "Lien_Structure_commande.h"
  19          #include "encodage_son.h"
  20          #include "son_sonore.h"
  21          #include "mesure_courant.h"
  22          
  23          #ifndef CFG_Globale
  24            #define CFG_Globale
  25            #include <CFG_Globale.h>
  26          #endif
  27          
  28          //------------------------------------------------------------------------------------
  29          // Déclarations des variables globales
  30          //------------------------------------------------------------------------------------
  31          
  32          char a;
  33          char i =0;
  34          char message_s[50] = {0};
  35          char mess[50] = {0};
  36          void tempo_emiss(void);
  37          struct COMMANDES_SERIALIZER commande_serializer;
  38          float courant_actuel;
  39          float dist_avant;
  40          float dist_arriere;
  41          char Angle_voulu,Angle_atteint,msg_Slave,angle;
  42          
  43          void routage(struct COMMANDES commande, enum Routage * type){
  44   1            
  45   1        if (commande.Etat_Servo==Servo_H){
  46   2          *type=Servo_Hor;
  47   2        }   
  48   1        else  if (commande.Etat_Servo==Servo_V){
  49   2          *type=Servo_Vert;
  50   2        }         
  51   1        else if (commande.Etat_Mouvement!=Mouvement_non){
  52   2          *type=Deplacement;
  53   2        }
  54   1        else if (commande.A_Obst!=DCT_non){
  55   2          *type=Obstacle;
C51 COMPILER V9.52.0.0   LIEN_STRUCTURE_COMMANDE                                           05/16/2018 12:04:52 PAGE 2   

  56   2        }
  57   1        else if (commande.Etat_Energie==Mesure_I){
  58   2          *type=Courant;
  59   2        }
  60   1        else if (commande.Etat_Energie==Mesure_E){
  61   2          *type=Energie;
  62   2        }
  63   1        else if ( commande.frequence!=0){
  64   2          *type=Gene_Son;
  65   2        }
  66   1      }
  67          // verifier attention effectuer les déclaration avant toute execution de code.    
  68          void fonctionRoutage(struct COMMANDES commande){
  69   1        enum Routage route = Initialisation;
  70   1        unsigned char commande_SPI = 0x00;
  71   1        unsigned char trame[1] = {0x00};
  72   1        unsigned char taille_trame = 1;
  73   1        double alpha;
  74   1        int distance;
  75   1        char angle_ascii[3];
  76   1        char mess[50] = {0};
  77   1        char mess1[50] = {0}; // utilisé dans le cas du déplacement élémentaire
  78   1        char mess2[50] = {0}; // idem
  79   1        char mess3[50] = {0}; // idem
  80   1        int compteur = 0;
  81   1        char msg_Slave_ascii[256];  
  82   1        struct INFORMATIONS info;
  83   1        char courant_ascii[4];
  84   1        char energie_ascii[4];
  85   1        routage(commande,&route);
  86   1        
  87   1        switch (route){
  88   2          case Servo_H: 
  89   2            Angle_voulu=commande.Servo_Angle;
  90   2            Angle_atteint = CDE_Servo_H(Angle_voulu);
  91   2            serOutstring("\n\r AS H");
  92   2            
  93   2            memset(mess,0,strlen(mess));
  94   2            strcpy(mess,angle_ascii);
  95   2            strcat(mess,"\n\r>");
  96   2            serOutstring(mess);
  97   2            break;
  98   2          
  99   2          case Servo_V:
 100   2            commande_SPI = 0xD3;
 101   2            trame[0]=commande.Servo_Angle;
 102   2            taille_trame = 1;
 103   2            echange_trame(trame,taille_trame,commande_SPI);
 104   2            tempo_emiss();
 105   2            msg_Slave = trame_recue();
 106   2            tempo_emiss();
 107   2      
 108   2            sprintf(msg_Slave_ascii,"%f",msg_Slave);
 109   2            serOutstring("\n\r AS V");
 110   2            serOutstring("\n\r>");
 111   2            break;
 112   2          
 113   2          case Deplacement: 
 114   2              
 115   2            if (commande.Etat_Mouvement == Depl_Coord) {
 116   3              alpha = atan(commande.Coord_Y / commande.Coord_X) * 180/3.1415; // résultat de atan en radian
 117   3              distance = ceil(pow(pow(commande.Coord_Y,2)+pow(commande.Coord_X,2),0.5)); // Pythagore
C51 COMPILER V9.52.0.0   LIEN_STRUCTURE_COMMANDE                                           05/16/2018 12:04:52 PAGE 3   

 118   3              if (alpha < 0){
 119   4                alpha+= 360; } 
 120   3              // !!! L'ordre de création des messages est important (écrasement de variable)  
 121   3              // instruction pour faire avancer le robot de la distance "distance"
 122   3              commande.Etat_Mouvement = Depl_Coord;
 123   3              commande.Coord_X = distance;
 124   3              commande_serializer = transcode_commande_to_serializer(commande);
 125   3              formate_serializer(commande_serializer, mess2);
 126   3                
 127   3              // Instruction  pour positionner le robot à l'angle finale
 128   3              commande.Etat_Mouvement = Rot_AngD;
 129   3              commande.Vitesse = 5;
 130   3              commande_serializer = transcode_commande_to_serializer(commande);
 131   3              formate_serializer(commande_serializer, mess3);
 132   3      
 133   3              // instruction pour positionner le robot dans l'angle de départ
 134   3              commande.Etat_Mouvement = Rot_AngD;
 135   3              commande.Vitesse = 5;
 136   3              commande.Angle = alpha;
 137   3              commande_serializer = transcode_commande_to_serializer(commande);
 138   3              formate_serializer(commande_serializer, mess1);
 139   3              
 140   3              serOutstring1(mess1);
 141   3              serOutstring("\r\n 1er com pppppppppppppppppppppppppppppp\r\n");
 142   3              serOutstring(mess1);
 143   3              compteur = 0;
 144   3      //        for(compteur = 0; compteur<65535; compteur++); //temporisation
 145   3              compteur=0;
 146   3              do {
 147   4                serOutstring1("pids\r"); // Attente que le serializer est fini (il renvoie 1 quand occupé et 0 sinon
 148   4                  do{ 
 149   5                    a=serInchar1();
 150   5                    if (a!=0x00){
 151   6                      mess[compteur]=a;
 152   6                      compteur=compteur+1;      
 153   6                        }
 154   5                    }while(a!=0x3E);
 155   4                  }while ( mess[compteur-1] == 1);
 156   3                          compteur = 0;
 157   3                  
 158   3              serOutstring("\r\n 2em com \r\n");
 159   3              serOutstring1(mess2);
 160   3              serOutstring(mess2);
 161   3      
 162   3      //        for(compteur = 0; compteur<65535; compteur++); //temporisation
 163   3              compteur=0;
 164   3              do {serOutstring1("pids\r");
 165   4                  do{ 
 166   5                    a=serInchar1();
 167   5                    if (a!=0x00){
 168   6                      mess[compteur]=a;
 169   6                      compteur=compteur+1;
 170   6                      }
 171   5                    }while(a!=0x3E);
 172   4                  }while ( mess[compteur-1] == 1);
 173   3                            compteur = 0;
 174   3      
 175   3              serOutstring("\r\n 3em com \r\n");
 176   3              serOutstring1(mess3);
 177   3              serOutstring(mess3);
 178   3      
 179   3            }
C51 COMPILER V9.52.0.0   LIEN_STRUCTURE_COMMANDE                                           05/16/2018 12:04:52 PAGE 4   

 180   2            else
 181   2            {
 182   3              commande_serializer = transcode_commande_to_serializer(commande);
 183   3              formate_serializer(commande_serializer, message_s);
 184   3              serOutstring1(message_s);
 185   3              serOutstring(message_s);
 186   3      
 187   3              i=0;
 188   3              a=0;
 189   3      
 190   3              do{ 
 191   4              a=serInchar1();
 192   4              if (a!=0x00){
 193   5                mess[i]=a;
 194   5                i=i+1;
 195   5              }
 196   4              }while(a!=0x3E);
 197   3            }
 198   2      
 199   2              
 200   2            mess[i] = '\0';
 201   2            serOutstring(mess);
 202   2            break;
 203   2            
 204   2          
 205   2          case Obstacle:
 206   2            memset(mess,0,strlen(mess));
 207   2            info = encode_son(commande);
 208   2            strcpy(mess,"\n\rDistance (cm) : ");
 209   2            serOutstring(mess);
 210   2            serOutstring(info.Tab_Val_Obst);
 211   2            serOutstring("\n\r>");
 212   2            memset(mess,0,strlen(mess));
 213   2            break;
 214   2        
 215   2          case Courant:
 216   2            info.Mesure_Courant = Courant_ADC();
 217   2            sprintf( courant_ascii,"%d", info.Mesure_Courant);
 218   2            serOutstring(courant_ascii);
 219   2            serOutstring("mA\n\r>");
 220   2            break;
 221   2          case Energie : 
 222   2            info.Mesure_Courant = Courant_ADC();
 223   2            info.Mesure_Energie = (int) 9.6*info.Mesure_Courant*2; // E = U*I*t
 224   2            sprintf(energie_ascii,"%d", info.Mesure_Energie);
 225   2            serOutstring(energie_ascii);
 226   2            serOutstring("J\n\r>");
 227   2            break;
 228   2          
 229   2          case Gene_Son:
 230   2            son_sonore(commande);
 231   2            break;
 232   2          
 233   2          default:
 234   2            strcpy(mess, "\n\r#\n\r>");
 235   2            serOutstring(mess);
 236   2            break;
 237   2          
 238   2        }
 239   1      }
 240          
 241          void tempo_emiss(void){ 
C51 COMPILER V9.52.0.0   LIEN_STRUCTURE_COMMANDE                                           05/16/2018 12:04:52 PAGE 5   

 242   1        unsigned int x = 0;
 243   1        
 244   1        for(x=0;x<65000;x++);
 245   1        for(x=0;x<65000;x++);
 246   1        for(x=0;x<65000;x++);
 247   1        for(x=0;x<65000;x++);
 248   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2021    ----
   CONSTANT SIZE    =    342    ----
   XDATA SIZE       =    133     584
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
