C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/22/2018 19:07:46 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE LIEN_STRUCTURE_COMMANDE
OBJECT MODULE PLACED IN Lien_Structure_commande.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Src\Lien_Structure_commande.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Lien_
                    -Structure_commande.lst) TABS(2) OBJECT(Lien_Structure_commande.obj)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   7          #include "Config_ADC.h"
   8          #include "Servomoteur_horizontal.h"
   9          #include "ultrason.h"
  10          #include "Fonctions_cote_serializer.h"
  11          #include "Declarations_GPIO.h"
  12          #include "Config_Globale.h"
  13          #include "Timers.h"
  14          #include "Config_SPI.h"
  15          #include "Transmission_SPI.h"
  16          #include "UART0_RingBuffer_lib.h"
  17          #include "ConfigUART1.h"
  18          #include "Lien_Structure_commande.h"
  19          #include "Detect_Obst.h"
  20          #include "Generation_son.h"
  21          #include "Mesure_courant.h"
  22          
  23          #ifndef CFG_Globale
  24            #define CFG_Globale
  25            #include "CFG_Globale.h"
  26          #endif
  27          
  28          //------------------------------------------------------------------------------------
  29          // D�clarations des variables globales
  30          //------------------------------------------------------------------------------------
  31          
  32          char a;
  33          char i =0;
  34          char message_s[50] = {0};
  35          char mess[50] = {0};
  36          void tempo_emiss(void);
  37          struct COMMANDES_SERIALIZER commande_serializer;
  38          float courant_actuel;
  39          float dist_avant;
  40          float dist_arriere;
  41          char Angle_voulu,msg_Slave,angle;
  42          signed int Angle_atteint = 0;
  43          extern unsigned int courant;
  44          extern double energie;
  45          
  46          void routage(struct COMMANDES commande, enum Routage * type){
  47   1      
  48   1        if (commande.Etat_Servo==Servo_H){
  49   2          *type=Servo_Hor;
  50   2        }
  51   1        else  if (commande.Etat_Servo==Servo_V){
  52   2          *type=Servo_Vert;
  53   2        }
  54   1        else if (commande.Etat_Mouvement!=Mouvement_non){
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/22/2018 19:07:46 PAGE 2   

  55   2          *type=Deplacement;
  56   2        }
  57   1        else if (commande.A_Obst!=DCT_non){
  58   2          *type=Obstacle;
  59   2        }
  60   1        else if (commande.Etat_Energie==Mesure_I){
  61   2          *type=Courant;
  62   2        }
  63   1        else if (commande.Etat_Energie==Mesure_E){
  64   2          *type=Energie;
  65   2        }
  66   1        else if ( commande.frequence!=0){
  67   2          *type=Gene_Son;
  68   2        }
  69   1      }
  70          // verifier attention effectuer les d�claration avant toute execution de code.
  71          void fonctionRoutage(struct COMMANDES commande){
  72   1        enum Routage route = Initialisation;
  73   1        unsigned char commande_SPI = 0x00;
  74   1        unsigned char trame[2] = 0;
  75   1        unsigned char taille_trame = 1;
  76   1        double alpha;
  77   1        int distance;
  78   1        char angle_ascii[3];
  79   1        char mess[50] = {0};
  80   1        char mess1[50] = {0}; // utilis� dans le cas du d�placement �l�mentaire
  81   1        char mess2[50] = {0}; // idem
  82   1        char mess3[50] = {0}; // idem
  83   1        int compteur = 0;
  84   1        char msg_Slave_ascii[256];
  85   1        struct INFORMATIONS info;
  86   1        char courant_ascii[4];
  87   1        char energie_ascii[4];
  88   1        extern char affichage [50];
  89   1        char string_s[1000] = {2};
  90   1        int cpt = 0;
  91   1        routage(commande,&route);
  92   1      
  93   1        switch (route){
  94   2      
  95   2      // OK
  96   2          case Servo_H:
  97   2            Angle_voulu=commande.Servo_Angle;
  98   2            Angle_atteint = CDE_Servo_H(Angle_voulu);
  99   2            serOutstring("\n\r AS H");
 100   2      
 101   2            memset(mess,0,strlen(mess));
 102   2            strcpy(mess,angle_ascii);
 103   2            strcat(mess,"\n\r>");
 104   2            serOutstring(mess);
 105   2            break;
 106   2      
 107   2      // OK
 108   2          case Servo_V:
 109   2            commande_SPI = 0xD3;
 110   2            trame[0]=commande.Servo_Angle;
 111   2            if (commande.Servo_Angle < 0){
 112   3              trame[1] = 0xAA; //Pour prévenir le Slave que l'angle qu'il va recevoir est négatif
 113   3              trame[0] =~ trame[0]; //On prend le complément pour ne pas envoyé un début ou une fin de trame dans
             - la SPI
 114   3            }
 115   2            else{
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/22/2018 19:07:46 PAGE 3   

 116   3              trame[1] = 0xBB;
 117   3            }
 118   2            taille_trame = 2;
 119   2            echange_trame(trame,taille_trame,commande_SPI);
 120   2            tempo_emiss();
 121   2            msg_Slave = trame_recue();
 122   2            tempo_emiss();
 123   2            sprintf(msg_Slave_ascii,"%f",msg_Slave);
 124   2            serOutstring("\n\r AS V");
 125   2            serOutstring("\n\r>");
 126   2            break;
 127   2            
 128   2      // A FINIR DE DEBEUGER
 129   2          case Deplacement:
 130   2            if (commande.Etat_Mouvement == Depl_Coord) {
 131   3              alpha = atan(commande.Coord_Y / commande.Coord_X) * 180/3.1415; // r�sultat de atan en radian
 132   3              distance = ceil(pow(pow(commande.Coord_Y,2)+pow(commande.Coord_X,2),0.5)); // Pythagore
 133   3              if (alpha < 0){
 134   4                alpha+= 360; }
 135   3              // !!! L'ordre de cr�ation des messages est important (�crasement de variable)
 136   3              // instruction pour faire avancer le robot de la distance "distance"
 137   3              commande.Etat_Mouvement = Depl_Coord;
 138   3              commande.Coord_X = distance;
 139   3              commande_serializer = transcode_commande_to_serializer(commande);
 140   3              formate_serializer(commande_serializer, mess2);
 141   3              // Instruction  pour positionner le robot � l'angle finale
 142   3              commande.Etat_Mouvement = Rot_AngD;
 143   3              commande.Vitesse = 5;
 144   3              commande_serializer = transcode_commande_to_serializer(commande);
 145   3              formate_serializer(commande_serializer, mess3);
 146   3              // instruction pour positionner le robot dans l'angle de d�part
 147   3              commande.Etat_Mouvement = Rot_AngD;
 148   3              commande.Vitesse = 5;
 149   3              commande.Angle = alpha;
 150   3              commande_serializer = transcode_commande_to_serializer(commande);
 151   3              formate_serializer(commande_serializer, mess1);
 152   3              serOutstring1(mess1);
 153   3              serOutstring("\r\n");
 154   3              serOutstring(mess1);
 155   3              compteur = 0;
 156   3              memset(string_s,2,strlen(string_s));
 157   3              for(cpt = 0; cpt<10000; cpt++) //temporisation
 158   3              {
 159   4                _nop_();
 160   4              }
 161   3              do{
 162   4                serOutstring1("pids\r");// Attente que le serializer est fini (il renvoie 1 quand occup� et 0 sinon
 163   4                serOutstring("pids\r\n");// Attente que le serializer est fini (il renvoie 1 quand occup� et 0 sino
             -n
 164   4                for(cpt = 0; cpt<10000; cpt++) //temporisation
 165   4                {
 166   5                  _nop_();
 167   5                } 
 168   4                  do{ // recup reponse pids
 169   5                      a=serInchar1();
 170   5                      if (a!=0x00){
 171   6                        string_s[compteur]=a;
 172   6                        compteur=compteur+1;
 173   6                        }
 174   5                    }while( (a!='>') && !(string_s[compteur-5]== '0' || string_s[compteur-5]== '1') );
 175   4                    compteur = 0;
 176   4                  }while ( string_s[compteur-5] == '0');
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/22/2018 19:07:46 PAGE 4   

 177   3                  compteur = 0;
 178   3              serOutstring("\r\n");
 179   3              serOutstring1(mess2);
 180   3              serOutstring(mess2);
 181   3              for(cpt = 0; cpt<10000; cpt++) //temporisation
 182   3              {
 183   4                _nop_();
 184   4              }
 185   3              compteur=0;
 186   3              do{
 187   4                
 188   4                serOutstring1("pids\r");// Attente que le serializer est fini (il renvoie 1 quand occup� et 0 sinon
 189   4                for(cpt = 0; cpt<10000; cpt++) //temporisation
 190   4                {
 191   5                  _nop_();
 192   5                } 
 193   4                do{ // recup message ACK
 194   5                    a=serInchar1();
 195   5                    if (a!=0x00){
 196   6                      string_s[compteur]=a;
 197   6                      compteur=compteur+1;
 198   6                    }
 199   5                }while(a!='>');
 200   4                    do{ // recup reponse pids
 201   5                      a=serInchar1();
 202   5                      if (a!=0x00){
 203   6                        string_s[compteur]=a;
 204   6                        compteur=compteur+1;
 205   6                      }
 206   5                    }while(a!='>');
 207   4                    
 208   4              }while ( string_s[compteur-4] == '0');
 209   3              compteur = 0;
 210   3              serOutstring("\r\n");
 211   3              serOutstring1(mess3);
 212   3              serOutstring(mess3);
 213   3            }
 214   2            else{
 215   3              commande_serializer = transcode_commande_to_serializer(commande);
 216   3              formate_serializer(commande_serializer, message_s);
 217   3              serOutstring1(message_s);
 218   3              serOutstring(message_s);
 219   3              i=0;
 220   3              a=0;
 221   3              do{
 222   4                a=serInchar1();
 223   4                if (a!=0x00){
 224   5                  mess[i]=a;
 225   5                  i=i+1;
 226   5                }
 227   4              }while(a!=0x3E);
 228   3            }
 229   2            mess[i] = '\0';
 230   2            serOutstring(mess);
 231   2            break;
 232   2      
 233   2      
 234   2      // A FINIR DE DEBEUGER (PB d'affichage et de cmd du servomoteur !)
 235   2          case Obstacle:
 236   2            Detect_Obst(commande);
 237   2            serOutstring(affichage);
 238   2            serOutstring("\n\r>");
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/22/2018 19:07:46 PAGE 5   

 239   2            memset(affichage,0,strlen(affichage));
 240   2            break;
 241   2      
 242   2      // OK
 243   2          case Courant:
 244   2            info.Mesure_Courant = courant;
 245   2            sprintf( courant_ascii,"%d", info.Mesure_Courant);
 246   2            serOutstring(courant_ascii);
 247   2            serOutstring("mA\n\r>");
 248   2            break;
 249   2          
 250   2      // OK
 251   2          case Energie :
 252   2            info.Mesure_Energie = energie;
 253   2            sprintf(energie_ascii,"%d", info.Mesure_Energie);
 254   2            serOutstring(energie_ascii);
 255   2            serOutstring("J\n\r>");
 256   2            break;
 257   2          
 258   2      // OK
 259   2          case Gene_Son:
 260   2            son_sonore(commande);
 261   2            serOutstring("\n\r>");
 262   2            break;
 263   2      
 264   2          default:
 265   2            strcpy(mess, "\n\r#\n\r>");
 266   2            serOutstring(mess);
 267   2            break;
 268   2      
 269   2        }
 270   1      }
 271          
 272          void tempo_emiss(void){
 273   1        unsigned int x = 0;
 274   1      
 275   1        for(x=0;x<65000;x++);
 276   1        for(x=0;x<65000;x++);
 277   1        for(x=0;x<65000;x++);
 278   1        for(x=0;x<65000;x++);
 279   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2271    ----
   CONSTANT SIZE    =   1262    ----
   XDATA SIZE       =    134    1589
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
